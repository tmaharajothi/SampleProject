(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const ko = require('knockout');
const octicons = require('octicons');
const moment = require('moment');
const components = require('ungit-components');
const storage = require('ungit-storage');

components.register('stash', args => new StashViewModel(args.server, args.repoPath));

class StashItemViewModel {
  constructor(stash, data) {
    this.stash = stash;
    this.server = stash.server;
    this.id = data.reflogId;
    this.sha1 = data.sha1;
    this.title = `${data.reflogName} ${moment(new Date(data.commitDate)).fromNow()}`;
    this.message = data.message;
    this.showCommitDiff = ko.observable(false);

    this.commitDiff = ko.observable(components.create('commitDiff', {
      fileLineDiffs: data.fileLineDiffs.slice(),
      sha1: this.sha1,
      repoPath: stash.repoPath,
      server: stash.server,
      showDiffButtons: ko.observable(true)
    }));
    this.dropIcon = octicons.x.toSVG({ 'height': 18 });
    this.applyIcon = octicons.pencil.toSVG({ 'height': 20 });
  }

  apply() {
    this.server.delPromise(`/stashes/${this.id}`, { path: this.stash.repoPath(), apply: true })
      .catch((e) => this.server.unhandledRejection(e));
  }

  drop() {
    components.create('yesnodialog', { title: 'Are you sure you want to drop the stash?', details: 'This operation cannot be undone.'})
      .show()
      .closeThen((diag) => {
        if (diag.result()) {
          this.server.delPromise(`/stashes/${this.id}`, { path: this.stash.repoPath() })
            .catch((e) => this.server.unhandledRejection(e));
        }
    });
  }

  toggleShowCommitDiffs() {
    this.showCommitDiff(!this.showCommitDiff());
  }
}

class StashViewModel {
  constructor(server, repoPath) {
    this.server = server;
    this.repoPath = repoPath;
    this.stashedChanges = ko.observable([]);
    this.isShow = ko.observable(storage.getItem('showStash') === 'true');
    this.visible = ko.computed(() => this.stashedChanges().length > 0 && this.isShow());
    this.expandIcon = octicons['chevron-right'].toSVG({ 'height': 18 });
    this.expandedIcon = octicons['chevron-down'].toSVG({ 'height': 22 });
    this.refresh();
  }

  updateNode(parentElement) {
    if (!this.isDisabled) ko.renderTemplate('stash', this, {}, parentElement);
  }

  onProgramEvent(event) {
    if (event.event == 'request-app-content-refresh' ||
      event.event == 'working-tree-changed' ||
      event.event == 'git-directory-changed')
      this.refresh();
  }

  refresh() {
    this.server.getPromise('/stashes', { path: this.repoPath() })
      .then(stashes => {
        let changed = this.stashedChanges().length != stashes.length;
        if (!changed) {
          changed = !this.stashedChanges().every(item1 => stashes.some(item2 => item1.sha1 == item2.sha1));
        }

        if (changed) {
          this.stashedChanges(stashes.map(item => new StashItemViewModel(this, item)));
        }
      }).catch(err => {
        if (err.errorCode != 'no-such-path') this.server.unhandledRejection(err);
      });
  }

  toggleShowStash() {
    this.isShow(!this.isShow());
    storage.setItem('showStash', this.isShow());
  }
}

},{"knockout":"knockout","moment":"moment","octicons":undefined,"ungit-components":"ungit-components","ungit-storage":"ungit-storage"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3N0YXNoL3N0YXNoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImNvbnN0IGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbmNvbnN0IG9jdGljb25zID0gcmVxdWlyZSgnb2N0aWNvbnMnKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuY29uc3QgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbmNvbnN0IHN0b3JhZ2UgPSByZXF1aXJlKCd1bmdpdC1zdG9yYWdlJyk7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3N0YXNoJywgYXJncyA9PiBuZXcgU3Rhc2hWaWV3TW9kZWwoYXJncy5zZXJ2ZXIsIGFyZ3MucmVwb1BhdGgpKTtcblxuY2xhc3MgU3Rhc2hJdGVtVmlld01vZGVsIHtcbiAgY29uc3RydWN0b3Ioc3Rhc2gsIGRhdGEpIHtcbiAgICB0aGlzLnN0YXNoID0gc3Rhc2g7XG4gICAgdGhpcy5zZXJ2ZXIgPSBzdGFzaC5zZXJ2ZXI7XG4gICAgdGhpcy5pZCA9IGRhdGEucmVmbG9nSWQ7XG4gICAgdGhpcy5zaGExID0gZGF0YS5zaGExO1xuICAgIHRoaXMudGl0bGUgPSBgJHtkYXRhLnJlZmxvZ05hbWV9ICR7bW9tZW50KG5ldyBEYXRlKGRhdGEuY29tbWl0RGF0ZSkpLmZyb21Ob3coKX1gO1xuICAgIHRoaXMubWVzc2FnZSA9IGRhdGEubWVzc2FnZTtcbiAgICB0aGlzLnNob3dDb21taXREaWZmID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cbiAgICB0aGlzLmNvbW1pdERpZmYgPSBrby5vYnNlcnZhYmxlKGNvbXBvbmVudHMuY3JlYXRlKCdjb21taXREaWZmJywge1xuICAgICAgZmlsZUxpbmVEaWZmczogZGF0YS5maWxlTGluZURpZmZzLnNsaWNlKCksXG4gICAgICBzaGExOiB0aGlzLnNoYTEsXG4gICAgICByZXBvUGF0aDogc3Rhc2gucmVwb1BhdGgsXG4gICAgICBzZXJ2ZXI6IHN0YXNoLnNlcnZlcixcbiAgICAgIHNob3dEaWZmQnV0dG9uczoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH0pKTtcbiAgICB0aGlzLmRyb3BJY29uID0gb2N0aWNvbnMueC50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KTtcbiAgICB0aGlzLmFwcGx5SWNvbiA9IG9jdGljb25zLnBlbmNpbC50b1NWRyh7ICdoZWlnaHQnOiAyMCB9KTtcbiAgfVxuXG4gIGFwcGx5KCkge1xuICAgIHRoaXMuc2VydmVyLmRlbFByb21pc2UoYC9zdGFzaGVzLyR7dGhpcy5pZH1gLCB7IHBhdGg6IHRoaXMuc3Rhc2gucmVwb1BhdGgoKSwgYXBwbHk6IHRydWUgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgfVxuXG4gIGRyb3AoKSB7XG4gICAgY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkcm9wIHRoZSBzdGFzaD8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nfSlcbiAgICAgIC5zaG93KClcbiAgICAgIC5jbG9zZVRoZW4oKGRpYWcpID0+IHtcbiAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgICB0aGlzLnNlcnZlci5kZWxQcm9taXNlKGAvc3Rhc2hlcy8ke3RoaXMuaWR9YCwgeyBwYXRoOiB0aGlzLnN0YXNoLnJlcG9QYXRoKCkgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlU2hvd0NvbW1pdERpZmZzKCkge1xuICAgIHRoaXMuc2hvd0NvbW1pdERpZmYoIXRoaXMuc2hvd0NvbW1pdERpZmYoKSk7XG4gIH1cbn1cblxuY2xhc3MgU3Rhc2hWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIHJlcG9QYXRoKSB7XG4gICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgdGhpcy5yZXBvUGF0aCA9IHJlcG9QYXRoO1xuICAgIHRoaXMuc3Rhc2hlZENoYW5nZXMgPSBrby5vYnNlcnZhYmxlKFtdKTtcbiAgICB0aGlzLmlzU2hvdyA9IGtvLm9ic2VydmFibGUoc3RvcmFnZS5nZXRJdGVtKCdzaG93U3Rhc2gnKSA9PT0gJ3RydWUnKTtcbiAgICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLnN0YXNoZWRDaGFuZ2VzKCkubGVuZ3RoID4gMCAmJiB0aGlzLmlzU2hvdygpKTtcbiAgICB0aGlzLmV4cGFuZEljb24gPSBvY3RpY29uc1snY2hldnJvbi1yaWdodCddLnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pO1xuICAgIHRoaXMuZXhwYW5kZWRJY29uID0gb2N0aWNvbnNbJ2NoZXZyb24tZG93biddLnRvU1ZHKHsgJ2hlaWdodCc6IDIyIH0pO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgdXBkYXRlTm9kZShwYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQpIGtvLnJlbmRlclRlbXBsYXRlKCdzdGFzaCcsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIG9uUHJvZ3JhbUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmV2ZW50ID09ICdyZXF1ZXN0LWFwcC1jb250ZW50LXJlZnJlc2gnIHx8XG4gICAgICBldmVudC5ldmVudCA9PSAnd29ya2luZy10cmVlLWNoYW5nZWQnIHx8XG4gICAgICBldmVudC5ldmVudCA9PSAnZ2l0LWRpcmVjdG9yeS1jaGFuZ2VkJylcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvc3Rhc2hlcycsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpIH0pXG4gICAgICAudGhlbihzdGFzaGVzID0+IHtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLnN0YXNoZWRDaGFuZ2VzKCkubGVuZ3RoICE9IHN0YXNoZXMubGVuZ3RoO1xuICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gIXRoaXMuc3Rhc2hlZENoYW5nZXMoKS5ldmVyeShpdGVtMSA9PiBzdGFzaGVzLnNvbWUoaXRlbTIgPT4gaXRlbTEuc2hhMSA9PSBpdGVtMi5zaGExKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgIHRoaXMuc3Rhc2hlZENoYW5nZXMoc3Rhc2hlcy5tYXAoaXRlbSA9PiBuZXcgU3Rhc2hJdGVtVmlld01vZGVsKHRoaXMsIGl0ZW0pKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIuZXJyb3JDb2RlICE9ICduby1zdWNoLXBhdGgnKSB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZXJyKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlU2hvd1N0YXNoKCkge1xuICAgIHRoaXMuaXNTaG93KCF0aGlzLmlzU2hvdygpKTtcbiAgICBzdG9yYWdlLnNldEl0ZW0oJ3Nob3dTdGFzaCcsIHRoaXMuaXNTaG93KCkpO1xuICB9XG59XG4iXX0=
