(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

const ko = require('knockout');
const components = require('ungit-components');
const diff2html = require('diff2html');
const promise = require("bluebird");
const sideBySideDiff = 'sidebysidediff';
const textDiff = 'textdiff';

components.register('textdiff', args => new TextDiffViewModel(args));
components.register('textdiff.type', () => new Type());
components.register('textdiff.wordwrap', () => new WordWrap());
components.register('textdiff.whitespace', () => new WhiteSpace());

const loadLimit = 100;

class WordWrap {
  constructor() {
    this.value = ko.observable(false);

    this.toggle = () => {
      this.value(!this.value());
    };
    this.text = ko.computed(() => this.value() ? 'Wrap Lines' : 'No Wrap');
    this.isActive = ko.computed(() => this.value());
  }
}

class Type {
  constructor() {
    if (!!ungit.config.diffType && ungit.config.diffType !== textDiff && ungit.config.diffType !== sideBySideDiff) {
      ungit.config.diffType = textDiff;
      console.log('Config "diffType" must be either "textdiff" or "sidebysidediff".');
    }

    this.value = ko.observable(ungit.config.diffType || textDiff);

    this.toggle = () => {
      this.value(this.value() === textDiff ? sideBySideDiff : textDiff);
    };
    this.text = ko.computed(() => this.value() === textDiff ? 'Inline' : 'Side By Side');
    this.isActive = ko.computed(() => this.value() === sideBySideDiff);
  }
}

class WhiteSpace {
  constructor() {
    this.value = ko.observable(ungit.config.ignoreWhiteSpaceDiff);

    this.toggle = () => {
      this.value(!this.value());
    };
    this.text = ko.computed(() => this.value() ? 'Show Whitespace' : 'Hide Whitespace');
    this.isActive = ko.computed(() => this.value());
  }
}

class TextDiffViewModel {
  constructor(args) {
    this.filename = args.filename;
    this.oldFilename = args.oldFilename
    this.repoPath = args.repoPath;
    this.server = args.server;
    this.sha1 = args.sha1;
    this.hasMore = ko.observable(false);
    this.diffJson = null;
    this.loadCount = loadLimit;
    this.textDiffType = args.textDiffType;
    this.whiteSpace = args.whiteSpace;
    this.isShowingDiffs = args.isShowingDiffs;
    this.editState = args.editState;
    this.wordWrap = args.wordWrap;
    this.patchLineList = args.patchLineList;
    this.numberOfSelectedPatchLines = 0;
    this.htmlSrc = undefined;
    this.isParsed = ko.observable(false);

    this.isShowingDiffs.subscribe(newValue => {
      if (newValue) this.render();
    });
    this.textDiffType.value.subscribe(() => {
      if (this.isShowingDiffs()) this.render();
    });
    this.whiteSpace.value.subscribe(() => {
      if (this.isShowingDiffs()) this.invalidateDiff();
    });

    if (this.isShowingDiffs()) { this.render(); }
  }

  updateNode(parentElement) {
    ko.renderTemplate('textdiff', this, {}, parentElement);
  }

  getDiffArguments() {
    return {
      file: this.filename,
      oldFile: this.oldFilename,
      path: this.repoPath(),
      sha1: this.sha1 ? this.sha1 : '',
      whiteSpace: this.whiteSpace.value()
    };
  }

  invalidateDiff() {
    this.diffJson = null;
    if (this.isShowingDiffs()) this.render();
  }

  getDiffJson() {
    return this.server.getPromise('/diff', this.getDiffArguments()).then((diffs) => {
      if (typeof diffs !== 'string') {
        // Invalid value means there is no changes, show dummy diff without any changes
        diffs = `diff --git a/${this.filename} b/${this.filename}
                  index aaaaaaaa..bbbbbbbb 111111
                  --- a/${this.filename}
                  +++ b/${this.filename}`;
      }
      this.diffJson = diff2html.parse(diffs);
    }).catch(err => {
      // The file existed before but has been removed, but we're trying to get a diff for it
      // Most likely it will just disappear with the next refresh of the staging area
      // so we just ignore the error here
      if (err.errorCode != 'no-such-file') this.server.unhandledRejection(err);
    });
  }

  render() {
    return (!this.diffJson ? this.getDiffJson() : promise.resolve())
      .then(() => {
        if (!this.diffJson || this.diffJson.length == 0) return; // check if diffs are available (binary files do not support them)

        if (!this.diffJson[0].allBlocks) {
          this.diffJson[0].allBlocks = this.diffJson[0].blocks;
        }

        let currentLoadCount = Math.max(this.loadCount, loadLimit);
        let lineCount = 0;
        let loadCount = 0;
        this.diffJson[0].blocks = this.diffJson[0].allBlocks.reduce((blocks, block) => {
          const length = block.lines.length;
          const remaining = currentLoadCount - lineCount;
          if (remaining > 0) {
            loadCount += length;
            blocks.push(block);
          }
          lineCount += length;
          return blocks;
        }, []);

        this.loadCount = loadCount;
        this.hasMore(lineCount > loadCount);

        let html = diff2html.html(this.diffJson, {
          outputFormat: this.textDiffType.value() === sideBySideDiff ? 'side-by-side' : 'line-by-line',
          drawFileList: false
        });

        this.numberOfSelectedPatchLines = 0;
        let index = 0;

        // ko's binding resolution is not recursive, which means below ko.bind refresh method doesn't work for
        // data bind at getPatchCheckBox that is rendered with "html" binding.
        // which is reason why manually updating the html content and refreshing kobinding to have it render...
        if (this.patchLineList) {
          html = html.replace(/<span class="d2h-code-line-[a-z]+">(\+|\-)/g, (match, capture) => {
            if (this.patchLineList()[index] === undefined) {
              this.patchLineList()[index] = true;
            }

            return this.getPatchCheckBox(capture, index, this.patchLineList()[index++]);
          });
        }

        if (html !== this.htmlSrc) {
          // diff has changed since last we displayed and need refresh
          this.htmlSrc = html;
          this.isParsed(false);
          this.isParsed(true);
        }
      });
  }

  loadMore() {
    this.loadCount += loadLimit;
    this.render();
  }

  getPatchCheckBox(symbol, index, isActive) {
    if (isActive) {
      this.numberOfSelectedPatchLines++;
    }
    return `<div class="d2h-code-line-prefix"><span data-bind="visible: editState() !== 'patched'">${symbol}</span><input ${isActive ? 'checked' : ''} type="checkbox" data-bind="visible: editState() === 'patched', click: togglePatchLine.bind($data, ${index})"></input></div>`;
  }

  togglePatchLine(index) {
    this.patchLineList()[index] = !this.patchLineList()[index];

    if (this.patchLineList()[index]) {
      this.numberOfSelectedPatchLines++;
    } else {
      this.numberOfSelectedPatchLines--;
    }

    if (this.numberOfSelectedPatchLines === 0) {
      this.editState('none');
    }

    return true;
  }
}

},{"bluebird":undefined,"diff2html":undefined,"knockout":"knockout","ungit-components":"ungit-components"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3RleHRkaWZmL3RleHRkaWZmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcbmNvbnN0IGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbmNvbnN0IGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG5jb25zdCBkaWZmMmh0bWwgPSByZXF1aXJlKCdkaWZmMmh0bWwnKTtcbmNvbnN0IHByb21pc2UgPSByZXF1aXJlKFwiYmx1ZWJpcmRcIik7XG5jb25zdCBzaWRlQnlTaWRlRGlmZiA9ICdzaWRlYnlzaWRlZGlmZic7XG5jb25zdCB0ZXh0RGlmZiA9ICd0ZXh0ZGlmZic7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3RleHRkaWZmJywgYXJncyA9PiBuZXcgVGV4dERpZmZWaWV3TW9kZWwoYXJncykpO1xuY29tcG9uZW50cy5yZWdpc3RlcigndGV4dGRpZmYudHlwZScsICgpID0+IG5ldyBUeXBlKCkpO1xuY29tcG9uZW50cy5yZWdpc3RlcigndGV4dGRpZmYud29yZHdyYXAnLCAoKSA9PiBuZXcgV29yZFdyYXAoKSk7XG5jb21wb25lbnRzLnJlZ2lzdGVyKCd0ZXh0ZGlmZi53aGl0ZXNwYWNlJywgKCkgPT4gbmV3IFdoaXRlU3BhY2UoKSk7XG5cbmNvbnN0IGxvYWRMaW1pdCA9IDEwMDtcblxuY2xhc3MgV29yZFdyYXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZhbHVlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cbiAgICB0aGlzLnRvZ2dsZSA9ICgpID0+IHtcbiAgICAgIHRoaXMudmFsdWUoIXRoaXMudmFsdWUoKSk7XG4gICAgfTtcbiAgICB0aGlzLnRleHQgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLnZhbHVlKCkgPyAnV3JhcCBMaW5lcycgOiAnTm8gV3JhcCcpO1xuICAgIHRoaXMuaXNBY3RpdmUgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLnZhbHVlKCkpO1xuICB9XG59XG5cbmNsYXNzIFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAoISF1bmdpdC5jb25maWcuZGlmZlR5cGUgJiYgdW5naXQuY29uZmlnLmRpZmZUeXBlICE9PSB0ZXh0RGlmZiAmJiB1bmdpdC5jb25maWcuZGlmZlR5cGUgIT09IHNpZGVCeVNpZGVEaWZmKSB7XG4gICAgICB1bmdpdC5jb25maWcuZGlmZlR5cGUgPSB0ZXh0RGlmZjtcbiAgICAgIGNvbnNvbGUubG9nKCdDb25maWcgXCJkaWZmVHlwZVwiIG11c3QgYmUgZWl0aGVyIFwidGV4dGRpZmZcIiBvciBcInNpZGVieXNpZGVkaWZmXCIuJyk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IGtvLm9ic2VydmFibGUodW5naXQuY29uZmlnLmRpZmZUeXBlIHx8IHRleHREaWZmKTtcblxuICAgIHRoaXMudG9nZ2xlID0gKCkgPT4ge1xuICAgICAgdGhpcy52YWx1ZSh0aGlzLnZhbHVlKCkgPT09IHRleHREaWZmID8gc2lkZUJ5U2lkZURpZmYgOiB0ZXh0RGlmZik7XG4gICAgfTtcbiAgICB0aGlzLnRleHQgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLnZhbHVlKCkgPT09IHRleHREaWZmID8gJ0lubGluZScgOiAnU2lkZSBCeSBTaWRlJyk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMudmFsdWUoKSA9PT0gc2lkZUJ5U2lkZURpZmYpO1xuICB9XG59XG5cbmNsYXNzIFdoaXRlU3BhY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZhbHVlID0ga28ub2JzZXJ2YWJsZSh1bmdpdC5jb25maWcuaWdub3JlV2hpdGVTcGFjZURpZmYpO1xuXG4gICAgdGhpcy50b2dnbGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnZhbHVlKCF0aGlzLnZhbHVlKCkpO1xuICAgIH07XG4gICAgdGhpcy50ZXh0ID0ga28uY29tcHV0ZWQoKCkgPT4gdGhpcy52YWx1ZSgpID8gJ1Nob3cgV2hpdGVzcGFjZScgOiAnSGlkZSBXaGl0ZXNwYWNlJyk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMudmFsdWUoKSk7XG4gIH1cbn1cblxuY2xhc3MgVGV4dERpZmZWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5maWxlbmFtZSA9IGFyZ3MuZmlsZW5hbWU7XG4gICAgdGhpcy5vbGRGaWxlbmFtZSA9IGFyZ3Mub2xkRmlsZW5hbWVcbiAgICB0aGlzLnJlcG9QYXRoID0gYXJncy5yZXBvUGF0aDtcbiAgICB0aGlzLnNlcnZlciA9IGFyZ3Muc2VydmVyO1xuICAgIHRoaXMuc2hhMSA9IGFyZ3Muc2hhMTtcbiAgICB0aGlzLmhhc01vcmUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmRpZmZKc29uID0gbnVsbDtcbiAgICB0aGlzLmxvYWRDb3VudCA9IGxvYWRMaW1pdDtcbiAgICB0aGlzLnRleHREaWZmVHlwZSA9IGFyZ3MudGV4dERpZmZUeXBlO1xuICAgIHRoaXMud2hpdGVTcGFjZSA9IGFyZ3Mud2hpdGVTcGFjZTtcbiAgICB0aGlzLmlzU2hvd2luZ0RpZmZzID0gYXJncy5pc1Nob3dpbmdEaWZmcztcbiAgICB0aGlzLmVkaXRTdGF0ZSA9IGFyZ3MuZWRpdFN0YXRlO1xuICAgIHRoaXMud29yZFdyYXAgPSBhcmdzLndvcmRXcmFwO1xuICAgIHRoaXMucGF0Y2hMaW5lTGlzdCA9IGFyZ3MucGF0Y2hMaW5lTGlzdDtcbiAgICB0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzID0gMDtcbiAgICB0aGlzLmh0bWxTcmMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc1BhcnNlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuXG4gICAgdGhpcy5pc1Nob3dpbmdEaWZmcy5zdWJzY3JpYmUobmV3VmFsdWUgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlKSB0aGlzLnJlbmRlcigpO1xuICAgIH0pO1xuICAgIHRoaXMudGV4dERpZmZUeXBlLnZhbHVlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1Nob3dpbmdEaWZmcygpKSB0aGlzLnJlbmRlcigpO1xuICAgIH0pO1xuICAgIHRoaXMud2hpdGVTcGFjZS52YWx1ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNTaG93aW5nRGlmZnMoKSkgdGhpcy5pbnZhbGlkYXRlRGlmZigpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuaXNTaG93aW5nRGlmZnMoKSkgeyB0aGlzLnJlbmRlcigpOyB9XG4gIH1cblxuICB1cGRhdGVOb2RlKHBhcmVudEVsZW1lbnQpIHtcbiAgICBrby5yZW5kZXJUZW1wbGF0ZSgndGV4dGRpZmYnLCB0aGlzLCB7fSwgcGFyZW50RWxlbWVudCk7XG4gIH1cblxuICBnZXREaWZmQXJndW1lbnRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxlOiB0aGlzLmZpbGVuYW1lLFxuICAgICAgb2xkRmlsZTogdGhpcy5vbGRGaWxlbmFtZSxcbiAgICAgIHBhdGg6IHRoaXMucmVwb1BhdGgoKSxcbiAgICAgIHNoYTE6IHRoaXMuc2hhMSA/IHRoaXMuc2hhMSA6ICcnLFxuICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLnZhbHVlKClcbiAgICB9O1xuICB9XG5cbiAgaW52YWxpZGF0ZURpZmYoKSB7XG4gICAgdGhpcy5kaWZmSnNvbiA9IG51bGw7XG4gICAgaWYgKHRoaXMuaXNTaG93aW5nRGlmZnMoKSkgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIGdldERpZmZKc29uKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvZGlmZicsIHRoaXMuZ2V0RGlmZkFyZ3VtZW50cygpKS50aGVuKChkaWZmcykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkaWZmcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSW52YWxpZCB2YWx1ZSBtZWFucyB0aGVyZSBpcyBubyBjaGFuZ2VzLCBzaG93IGR1bW15IGRpZmYgd2l0aG91dCBhbnkgY2hhbmdlc1xuICAgICAgICBkaWZmcyA9IGBkaWZmIC0tZ2l0IGEvJHt0aGlzLmZpbGVuYW1lfSBiLyR7dGhpcy5maWxlbmFtZX1cbiAgICAgICAgICAgICAgICAgIGluZGV4IGFhYWFhYWFhLi5iYmJiYmJiYiAxMTExMTFcbiAgICAgICAgICAgICAgICAgIC0tLSBhLyR7dGhpcy5maWxlbmFtZX1cbiAgICAgICAgICAgICAgICAgICsrKyBiLyR7dGhpcy5maWxlbmFtZX1gO1xuICAgICAgfVxuICAgICAgdGhpcy5kaWZmSnNvbiA9IGRpZmYyaHRtbC5wYXJzZShkaWZmcyk7XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIC8vIFRoZSBmaWxlIGV4aXN0ZWQgYmVmb3JlIGJ1dCBoYXMgYmVlbiByZW1vdmVkLCBidXQgd2UncmUgdHJ5aW5nIHRvIGdldCBhIGRpZmYgZm9yIGl0XG4gICAgICAvLyBNb3N0IGxpa2VseSBpdCB3aWxsIGp1c3QgZGlzYXBwZWFyIHdpdGggdGhlIG5leHQgcmVmcmVzaCBvZiB0aGUgc3RhZ2luZyBhcmVhXG4gICAgICAvLyBzbyB3ZSBqdXN0IGlnbm9yZSB0aGUgZXJyb3IgaGVyZVxuICAgICAgaWYgKGVyci5lcnJvckNvZGUgIT0gJ25vLXN1Y2gtZmlsZScpIHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoIXRoaXMuZGlmZkpzb24gPyB0aGlzLmdldERpZmZKc29uKCkgOiBwcm9taXNlLnJlc29sdmUoKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmRpZmZKc29uIHx8IHRoaXMuZGlmZkpzb24ubGVuZ3RoID09IDApIHJldHVybjsgLy8gY2hlY2sgaWYgZGlmZnMgYXJlIGF2YWlsYWJsZSAoYmluYXJ5IGZpbGVzIGRvIG5vdCBzdXBwb3J0IHRoZW0pXG5cbiAgICAgICAgaWYgKCF0aGlzLmRpZmZKc29uWzBdLmFsbEJsb2Nrcykge1xuICAgICAgICAgIHRoaXMuZGlmZkpzb25bMF0uYWxsQmxvY2tzID0gdGhpcy5kaWZmSnNvblswXS5ibG9ja3M7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudExvYWRDb3VudCA9IE1hdGgubWF4KHRoaXMubG9hZENvdW50LCBsb2FkTGltaXQpO1xuICAgICAgICBsZXQgbGluZUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGxvYWRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZGlmZkpzb25bMF0uYmxvY2tzID0gdGhpcy5kaWZmSnNvblswXS5hbGxCbG9ja3MucmVkdWNlKChibG9ja3MsIGJsb2NrKSA9PiB7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gYmxvY2subGluZXMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGN1cnJlbnRMb2FkQ291bnQgLSBsaW5lQ291bnQ7XG4gICAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgIGxvYWRDb3VudCArPSBsZW5ndGg7XG4gICAgICAgICAgICBibG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmVDb3VudCArPSBsZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrcztcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIHRoaXMubG9hZENvdW50ID0gbG9hZENvdW50O1xuICAgICAgICB0aGlzLmhhc01vcmUobGluZUNvdW50ID4gbG9hZENvdW50KTtcblxuICAgICAgICBsZXQgaHRtbCA9IGRpZmYyaHRtbC5odG1sKHRoaXMuZGlmZkpzb24sIHtcbiAgICAgICAgICBvdXRwdXRGb3JtYXQ6IHRoaXMudGV4dERpZmZUeXBlLnZhbHVlKCkgPT09IHNpZGVCeVNpZGVEaWZmID8gJ3NpZGUtYnktc2lkZScgOiAnbGluZS1ieS1saW5lJyxcbiAgICAgICAgICBkcmF3RmlsZUxpc3Q6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubnVtYmVyT2ZTZWxlY3RlZFBhdGNoTGluZXMgPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIGtvJ3MgYmluZGluZyByZXNvbHV0aW9uIGlzIG5vdCByZWN1cnNpdmUsIHdoaWNoIG1lYW5zIGJlbG93IGtvLmJpbmQgcmVmcmVzaCBtZXRob2QgZG9lc24ndCB3b3JrIGZvclxuICAgICAgICAvLyBkYXRhIGJpbmQgYXQgZ2V0UGF0Y2hDaGVja0JveCB0aGF0IGlzIHJlbmRlcmVkIHdpdGggXCJodG1sXCIgYmluZGluZy5cbiAgICAgICAgLy8gd2hpY2ggaXMgcmVhc29uIHdoeSBtYW51YWxseSB1cGRhdGluZyB0aGUgaHRtbCBjb250ZW50IGFuZCByZWZyZXNoaW5nIGtvYmluZGluZyB0byBoYXZlIGl0IHJlbmRlci4uLlxuICAgICAgICBpZiAodGhpcy5wYXRjaExpbmVMaXN0KSB7XG4gICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvPHNwYW4gY2xhc3M9XCJkMmgtY29kZS1saW5lLVthLXpdK1wiPihcXCt8XFwtKS9nLCAobWF0Y2gsIGNhcHR1cmUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXRjaENoZWNrQm94KGNhcHR1cmUsIGluZGV4LCB0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleCsrXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaHRtbCAhPT0gdGhpcy5odG1sU3JjKSB7XG4gICAgICAgICAgLy8gZGlmZiBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IHdlIGRpc3BsYXllZCBhbmQgbmVlZCByZWZyZXNoXG4gICAgICAgICAgdGhpcy5odG1sU3JjID0gaHRtbDtcbiAgICAgICAgICB0aGlzLmlzUGFyc2VkKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmlzUGFyc2VkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIGxvYWRNb3JlKCkge1xuICAgIHRoaXMubG9hZENvdW50ICs9IGxvYWRMaW1pdDtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgZ2V0UGF0Y2hDaGVja0JveChzeW1ib2wsIGluZGV4LCBpc0FjdGl2ZSkge1xuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcysrO1xuICAgIH1cbiAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJkMmgtY29kZS1saW5lLXByZWZpeFwiPjxzcGFuIGRhdGEtYmluZD1cInZpc2libGU6IGVkaXRTdGF0ZSgpICE9PSAncGF0Y2hlZCdcIj4ke3N5bWJvbH08L3NwYW4+PGlucHV0ICR7aXNBY3RpdmUgPyAnY2hlY2tlZCcgOiAnJ30gdHlwZT1cImNoZWNrYm94XCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZWRpdFN0YXRlKCkgPT09ICdwYXRjaGVkJywgY2xpY2s6IHRvZ2dsZVBhdGNoTGluZS5iaW5kKCRkYXRhLCAke2luZGV4fSlcIj48L2lucHV0PjwvZGl2PmA7XG4gIH1cblxuICB0b2dnbGVQYXRjaExpbmUoaW5kZXgpIHtcbiAgICB0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleF0gPSAhdGhpcy5wYXRjaExpbmVMaXN0KClbaW5kZXhdO1xuXG4gICAgaWYgKHRoaXMucGF0Y2hMaW5lTGlzdCgpW2luZGV4XSkge1xuICAgICAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzLS07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubnVtYmVyT2ZTZWxlY3RlZFBhdGNoTGluZXMgPT09IDApIHtcbiAgICAgIHRoaXMuZWRpdFN0YXRlKCdub25lJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdfQ==
