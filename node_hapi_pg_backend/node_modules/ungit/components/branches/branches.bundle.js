(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const ko = require('knockout');
const _ = require('lodash');
const octicons = require('octicons');
const components = require('ungit-components');
const programEvents = require('ungit-program-events');
const storage = require('ungit-storage');
const showRemote = 'showRemote';
const showBranch = 'showBranch';
const showTag = 'showTag';

components.register('branches', (args) => {
  return new BranchesViewModel(args.server, args.graph, args.repoPath);
});

class BranchesViewModel {
  constructor(server, graph, repoPath) {
    this.repoPath = repoPath;
    this.server = server;
    this.branchesAndLocalTags = ko.observableArray();
    this.current = ko.observable();
    this.isShowRemote = ko.observable(storage.getItem(showRemote) != 'false');
    this.isShowBranch = ko.observable(storage.getItem(showBranch) != 'false');
    this.isShowTag = ko.observable(storage.getItem(showTag) != 'false');
    this.graph = graph;
    const setLocalStorageAndUpdate = (localStorageKey, value) => {
      storage.setItem(localStorageKey, value);
      this.updateRefs();
      return value;
    };
    this.isShowRemote.subscribe(setLocalStorageAndUpdate.bind(null, showRemote));
    this.isShowBranch.subscribe(setLocalStorageAndUpdate.bind(null, showBranch));
    this.isShowTag.subscribe(setLocalStorageAndUpdate.bind(null, showTag));
    this.refsLabel = ko.computed(() => this.current() || 'master (no commits yet)');
    this.listRefsEnabled = ko.computed(() => this.branchesAndLocalTags().length > 0);
    this.branchIcon = octicons['git-branch'].toSVG({ 'height': 18 });
    this.closeIcon = octicons.x.toSVG({ 'height': 18 });
    this.updateRefsDebounced = _.debounce(this.updateRefs, 500);
  }

  checkoutBranch(branch) { branch.checkout(); }
  updateNode(parentElement) { ko.renderTemplate('branches', this, {}, parentElement); }
  clickFetch() { this.updateRefs(); }
  onProgramEvent(event) {
    if (event.event === 'working-tree-changed' || event.event === 'request-app-content-refresh' ||
      event.event === 'branch-updated' || event.event === 'git-directory-changed') {
      this.updateRefsDebounced();
    }
  }
  updateRefs() {
    const currentBranchProm = this.server.getPromise('/branches', { path: this.repoPath() })
      .then((branches) => branches.forEach((b) => { if (b.current) { this.current(b.name); } }))
      .catch((err) => { this.current('~error'); });

    // refreshes tags branches and remote branches
    const refsProm = this.server.getPromise('/refs', { path: this.repoPath() })
      .then((refs) => {
        const version = Date.now();
        const sorted = refs.map((r) => {
          const ref = this.graph.getRef(r.name.replace('refs/tags', 'tag: refs/tags'));
          ref.node(this.graph.getNode(r.sha1));
          ref.version = version;
          return ref;
        }).sort((a, b) => {
          if (a.current() || b.current()) {
            return a.current() ? -1 : 1;
          } else if (a.isRemoteBranch === b.isRemoteBranch) {
            if (a.name < b.name) {
               return -1;
            } if (a.name > b.name) {
              return 1;
            }
            return 0;
          } else {
            return a.isRemoteBranch ? 1 : -1;
          }
        }).filter((ref) => {
          if (ref.localRefName == 'refs/stash')     return false;
          if (ref.localRefName.endsWith('/HEAD'))   return false;
          if (!this.isShowRemote() && ref.isRemote) return false;
          if (!this.isShowBranch() && ref.isBranch) return false;
          if (!this.isShowTag() && ref.isTag)       return false;
          return true;
        });
        this.branchesAndLocalTags(sorted);
        this.graph.refs().forEach((ref) => {
          // ref was removed from another source
          if (!ref.isRemoteTag && ref.value !== 'HEAD' && (!ref.version || ref.version < version)) {
            ref.remove(true);
          }
        });
      }).catch((e) => this.server.unhandledRejection(e));

    return Promise.all([currentBranchProm, refsProm]);
  }

  branchRemove(branch) {
    let details = `"${branch.refName}"`;
    if (branch.isRemoteBranch) {
      details = `<code style='font-size: 100%'>REMOTE</code> ${details}`;
    }
    components.create('yesnodialog', { title: 'Are you sure?', details: 'Deleting ' + details + ' branch cannot be undone with ungit.'})
      .show()
      .closeThen((diag) => {
        if (!diag.result()) return;
        const url = `${branch.isRemote ? '/remote' : ''}/branches`;
        return this.server.delPromise(url, { path: this.graph.repoPath(), remote: branch.isRemote ? branch.remote : null, name: branch.refName })
          .then(() => programEvents.dispatch({ event: 'working-tree-changed' }))
          .catch((e) => this.server.unhandledRejection(e));
      });
  }
}

},{"knockout":"knockout","lodash":"lodash","octicons":undefined,"ungit-components":"ungit-components","ungit-program-events":"ungit-program-events","ungit-storage":"ungit-storage"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2JyYW5jaGVzL2JyYW5jaGVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJjb25zdCBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBvY3RpY29ucyA9IHJlcXVpcmUoJ29jdGljb25zJyk7XG5jb25zdCBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xuY29uc3QgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG5jb25zdCBzdG9yYWdlID0gcmVxdWlyZSgndW5naXQtc3RvcmFnZScpO1xuY29uc3Qgc2hvd1JlbW90ZSA9ICdzaG93UmVtb3RlJztcbmNvbnN0IHNob3dCcmFuY2ggPSAnc2hvd0JyYW5jaCc7XG5jb25zdCBzaG93VGFnID0gJ3Nob3dUYWcnO1xuXG5jb21wb25lbnRzLnJlZ2lzdGVyKCdicmFuY2hlcycsIChhcmdzKSA9PiB7XG4gIHJldHVybiBuZXcgQnJhbmNoZXNWaWV3TW9kZWwoYXJncy5zZXJ2ZXIsIGFyZ3MuZ3JhcGgsIGFyZ3MucmVwb1BhdGgpO1xufSk7XG5cbmNsYXNzIEJyYW5jaGVzVmlld01vZGVsIHtcbiAgY29uc3RydWN0b3Ioc2VydmVyLCBncmFwaCwgcmVwb1BhdGgpIHtcbiAgICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgdGhpcy5icmFuY2hlc0FuZExvY2FsVGFncyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICAgIHRoaXMuY3VycmVudCA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLmlzU2hvd1JlbW90ZSA9IGtvLm9ic2VydmFibGUoc3RvcmFnZS5nZXRJdGVtKHNob3dSZW1vdGUpICE9ICdmYWxzZScpO1xuICAgIHRoaXMuaXNTaG93QnJhbmNoID0ga28ub2JzZXJ2YWJsZShzdG9yYWdlLmdldEl0ZW0oc2hvd0JyYW5jaCkgIT0gJ2ZhbHNlJyk7XG4gICAgdGhpcy5pc1Nob3dUYWcgPSBrby5vYnNlcnZhYmxlKHN0b3JhZ2UuZ2V0SXRlbShzaG93VGFnKSAhPSAnZmFsc2UnKTtcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgY29uc3Qgc2V0TG9jYWxTdG9yYWdlQW5kVXBkYXRlID0gKGxvY2FsU3RvcmFnZUtleSwgdmFsdWUpID0+IHtcbiAgICAgIHN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VLZXksIHZhbHVlKTtcbiAgICAgIHRoaXMudXBkYXRlUmVmcygpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgdGhpcy5pc1Nob3dSZW1vdGUuc3Vic2NyaWJlKHNldExvY2FsU3RvcmFnZUFuZFVwZGF0ZS5iaW5kKG51bGwsIHNob3dSZW1vdGUpKTtcbiAgICB0aGlzLmlzU2hvd0JyYW5jaC5zdWJzY3JpYmUoc2V0TG9jYWxTdG9yYWdlQW5kVXBkYXRlLmJpbmQobnVsbCwgc2hvd0JyYW5jaCkpO1xuICAgIHRoaXMuaXNTaG93VGFnLnN1YnNjcmliZShzZXRMb2NhbFN0b3JhZ2VBbmRVcGRhdGUuYmluZChudWxsLCBzaG93VGFnKSk7XG4gICAgdGhpcy5yZWZzTGFiZWwgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLmN1cnJlbnQoKSB8fCAnbWFzdGVyIChubyBjb21taXRzIHlldCknKTtcbiAgICB0aGlzLmxpc3RSZWZzRW5hYmxlZCA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3MoKS5sZW5ndGggPiAwKTtcbiAgICB0aGlzLmJyYW5jaEljb24gPSBvY3RpY29uc1snZ2l0LWJyYW5jaCddLnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pO1xuICAgIHRoaXMuY2xvc2VJY29uID0gb2N0aWNvbnMueC50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KTtcbiAgICB0aGlzLnVwZGF0ZVJlZnNEZWJvdW5jZWQgPSBfLmRlYm91bmNlKHRoaXMudXBkYXRlUmVmcywgNTAwKTtcbiAgfVxuXG4gIGNoZWNrb3V0QnJhbmNoKGJyYW5jaCkgeyBicmFuY2guY2hlY2tvdXQoKTsgfVxuICB1cGRhdGVOb2RlKHBhcmVudEVsZW1lbnQpIHsga28ucmVuZGVyVGVtcGxhdGUoJ2JyYW5jaGVzJywgdGhpcywge30sIHBhcmVudEVsZW1lbnQpOyB9XG4gIGNsaWNrRmV0Y2goKSB7IHRoaXMudXBkYXRlUmVmcygpOyB9XG4gIG9uUHJvZ3JhbUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmV2ZW50ID09PSAnd29ya2luZy10cmVlLWNoYW5nZWQnIHx8IGV2ZW50LmV2ZW50ID09PSAncmVxdWVzdC1hcHAtY29udGVudC1yZWZyZXNoJyB8fFxuICAgICAgZXZlbnQuZXZlbnQgPT09ICdicmFuY2gtdXBkYXRlZCcgfHwgZXZlbnQuZXZlbnQgPT09ICdnaXQtZGlyZWN0b3J5LWNoYW5nZWQnKSB7XG4gICAgICB0aGlzLnVwZGF0ZVJlZnNEZWJvdW5jZWQoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmVmcygpIHtcbiAgICBjb25zdCBjdXJyZW50QnJhbmNoUHJvbSA9IHRoaXMuc2VydmVyLmdldFByb21pc2UoJy9icmFuY2hlcycsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpIH0pXG4gICAgICAudGhlbigoYnJhbmNoZXMpID0+IGJyYW5jaGVzLmZvckVhY2goKGIpID0+IHsgaWYgKGIuY3VycmVudCkgeyB0aGlzLmN1cnJlbnQoYi5uYW1lKTsgfSB9KSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7IHRoaXMuY3VycmVudCgnfmVycm9yJyk7IH0pO1xuXG4gICAgLy8gcmVmcmVzaGVzIHRhZ3MgYnJhbmNoZXMgYW5kIHJlbW90ZSBicmFuY2hlc1xuICAgIGNvbnN0IHJlZnNQcm9tID0gdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL3JlZnMnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSB9KVxuICAgICAgLnRoZW4oKHJlZnMpID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IHJlZnMubWFwKChyKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5ncmFwaC5nZXRSZWYoci5uYW1lLnJlcGxhY2UoJ3JlZnMvdGFncycsICd0YWc6IHJlZnMvdGFncycpKTtcbiAgICAgICAgICByZWYubm9kZSh0aGlzLmdyYXBoLmdldE5vZGUoci5zaGExKSk7XG4gICAgICAgICAgcmVmLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH0pLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICBpZiAoYS5jdXJyZW50KCkgfHwgYi5jdXJyZW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmN1cnJlbnQoKSA/IC0xIDogMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEuaXNSZW1vdGVCcmFuY2ggPT09IGIuaXNSZW1vdGVCcmFuY2gpIHtcbiAgICAgICAgICAgIGlmIChhLm5hbWUgPCBiLm5hbWUpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gaWYgKGEubmFtZSA+IGIubmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pc1JlbW90ZUJyYW5jaCA/IDEgOiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbHRlcigocmVmKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZi5sb2NhbFJlZk5hbWUgPT0gJ3JlZnMvc3Rhc2gnKSAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChyZWYubG9jYWxSZWZOYW1lLmVuZHNXaXRoKCcvSEVBRCcpKSAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNTaG93UmVtb3RlKCkgJiYgcmVmLmlzUmVtb3RlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzU2hvd0JyYW5jaCgpICYmIHJlZi5pc0JyYW5jaCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmICghdGhpcy5pc1Nob3dUYWcoKSAmJiByZWYuaXNUYWcpICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3Moc29ydGVkKTtcbiAgICAgICAgdGhpcy5ncmFwaC5yZWZzKCkuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICAgICAgLy8gcmVmIHdhcyByZW1vdmVkIGZyb20gYW5vdGhlciBzb3VyY2VcbiAgICAgICAgICBpZiAoIXJlZi5pc1JlbW90ZVRhZyAmJiByZWYudmFsdWUgIT09ICdIRUFEJyAmJiAoIXJlZi52ZXJzaW9uIHx8IHJlZi52ZXJzaW9uIDwgdmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJlZi5yZW1vdmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtjdXJyZW50QnJhbmNoUHJvbSwgcmVmc1Byb21dKTtcbiAgfVxuXG4gIGJyYW5jaFJlbW92ZShicmFuY2gpIHtcbiAgICBsZXQgZGV0YWlscyA9IGBcIiR7YnJhbmNoLnJlZk5hbWV9XCJgO1xuICAgIGlmIChicmFuY2guaXNSZW1vdGVCcmFuY2gpIHtcbiAgICAgIGRldGFpbHMgPSBgPGNvZGUgc3R5bGU9J2ZvbnQtc2l6ZTogMTAwJSc+UkVNT1RFPC9jb2RlPiAke2RldGFpbHN9YDtcbiAgICB9XG4gICAgY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZT8nLCBkZXRhaWxzOiAnRGVsZXRpbmcgJyArIGRldGFpbHMgKyAnIGJyYW5jaCBjYW5ub3QgYmUgdW5kb25lIHdpdGggdW5naXQuJ30pXG4gICAgICAuc2hvdygpXG4gICAgICAuY2xvc2VUaGVuKChkaWFnKSA9PiB7XG4gICAgICAgIGlmICghZGlhZy5yZXN1bHQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHticmFuY2guaXNSZW1vdGUgPyAnL3JlbW90ZScgOiAnJ30vYnJhbmNoZXNgO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIuZGVsUHJvbWlzZSh1cmwsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCByZW1vdGU6IGJyYW5jaC5pc1JlbW90ZSA/IGJyYW5jaC5yZW1vdGUgOiBudWxsLCBuYW1lOiBicmFuY2gucmVmTmFtZSB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ3dvcmtpbmctdHJlZS1jaGFuZ2VkJyB9KSlcbiAgICAgICAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSk7XG4gICAgICB9KTtcbiAgfVxufVxuIl19
