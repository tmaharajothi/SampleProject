(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const ko = require('knockout');
const Selectable = require('./selectable');

require('mina');

class Animateable extends Selectable {
  constructor(graph) {
    super(graph);
    this.element = ko.observable();
    this.previousGraph = undefined;
    this.element.subscribe(val => {
      if (val) this.animate(true);
    });
    this.animate = (forceRefresh) => {
      const currentGraph = this.getGraphAttr();
      if (this.element() && (forceRefresh || JSON.stringify(currentGraph) !== JSON.stringify(this.previousGraph))) {
        // dom is valid and force refresh is requested or dom moved, redraw
        if (ungit.config.isAnimate) {
          const now = Date.now();
          window.mina(this.previousGraph || currentGraph, currentGraph, now, now + 750, window.mina.time, val => {
            this.setGraphAttr(val);
          }, window.mina.elastic);
        } else {
          this.setGraphAttr(currentGraph);
        }
        this.previousGraph = currentGraph;
      }
    }
  }
}
module.exports = Animateable;

},{"./selectable":8,"knockout":"knockout","mina":undefined}],2:[function(require,module,exports){
const ko = require('knockout');
const Animateable = require('./animateable');

class EdgeViewModel extends Animateable {
  constructor(graph, nodeAsha1, nodeBsha1) {
    super(graph);
    this.nodeA = graph.getNode(nodeAsha1);
    this.nodeB = graph.getNode(nodeBsha1);
    this.getGraphAttr = ko.computed(() => {
      if (this.nodeA.isViewable() && (!this.nodeB.isViewable() || !this.nodeB.isInited)) {
        return [this.nodeA.cx(), this.nodeA.cy(), this.nodeA.cx(), this.nodeA.cy(),
                this.nodeA.cx(), graph.graphHeight(), this.nodeA.cx(), graph.graphHeight()];
      } else if (this.nodeB.isInited && this.nodeB.cx() && this.nodeB.cy()) {
        return [this.nodeA.cx(), this.nodeA.cy(), this.nodeA.cx(), this.nodeA.cy(),
                this.nodeB.cx(), this.nodeB.cy(), this.nodeB.cx(), this.nodeB.cy()];
      } else {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
    });
    this.getGraphAttr.subscribe(this.animate.bind(this));
  }

  setGraphAttr(val) {
    this.element().setAttribute('d', `M${val.slice(0,4).join(',')}L${val.slice(4,8).join(',')}`);
  }

  edgeMouseOver() {
    if (this.nodeA) {
      this.nodeA.isEdgeHighlighted(true);
    }
    if (this.nodeB) {
      this.nodeB.isEdgeHighlighted(true);
    }
  }

  edgeMouseOut() {
    if (this.nodeA) {
      this.nodeA.isEdgeHighlighted(false);
    }
    if (this.nodeB) {
      this.nodeB.isEdgeHighlighted(false);
    }
  }
}

module.exports = EdgeViewModel;

},{"./animateable":1,"knockout":"knockout"}],3:[function(require,module,exports){
const ko = require('knockout');
const octicons = require('octicons');
const components = require('ungit-components');
const programEvents = require('ungit-program-events');
const RefViewModel = require('./git-ref.js');
const HoverActions = require('./hover-actions');

const RebaseViewModel = HoverActions.RebaseViewModel;
const MergeViewModel = HoverActions.MergeViewModel;
const ResetViewModel = HoverActions.ResetViewModel;
const PushViewModel = HoverActions.PushViewModel;
const SquashViewModel = HoverActions.SquashViewModel;

class ActionBase {
  constructor(graph, text, style, icon) {
    this.graph = graph;
    this.server = graph.server;
    this.isRunning = ko.observable(false);
    this.isHighlighted = ko.computed(() => !graph.hoverGraphAction() || graph.hoverGraphAction() == this);
    this.text = text;
    this.style = style;
    this.icon = icon;
    this.cssClasses = ko.computed(() => {
      if (!this.isHighlighted() || this.isRunning()) {
        return `${this.style} dimmed`;
      } else {
        return this.style;
      }
    });
  }

  doPerform() {
    if (this.isRunning()) return;
    this.graph.hoverGraphAction(null);
    this.isRunning(true);
    return this.perform()
      .catch((e) => this.server.unhandledRejection(e))
      .finally(() => { this.isRunning(false); });
  }

  dragEnter() {
    if (!this.visible()) return;
    this.graph.hoverGraphAction(this);
  }

  dragLeave() {
    if (!this.visible()) return;
    this.graph.hoverGraphAction(null);
  }

  mouseover() {
    this.graph.hoverGraphAction(this);
  }

  mouseout() {
    this.graph.hoverGraphAction(null);
  }
}


class Move extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Move', 'move', octicons['arrow-left'].toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      return this.graph.currentActionContext() instanceof RefViewModel &&
        this.graph.currentActionContext().node() != this.node;
    });
  }

  perform() {
    return this.graph.currentActionContext().moveTo(this.node.sha1);
  }
}


class Reset extends ActionBase {
  constructor (graph, node) {
    super(graph, 'Reset', 'reset', octicons.trashcan.toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      if (!(this.graph.currentActionContext() instanceof RefViewModel)) return false;
      const context = this.graph.currentActionContext();
      if (context.node() != this.node) return false;
      const remoteRef = context.getRemoteRef(this.graph.currentRemote());
      return remoteRef && remoteRef.node() &&
        context && context.node() &&
        remoteRef.node() != context.node() &&
        remoteRef.node().date < context.node().date;
    });
  }

  createHoverGraphic() {
    const context = this.graph.currentActionContext();
    if (!context) return null;
    const remoteRef = context.getRemoteRef(this.graph.currentRemote());
    const nodes = context.node().getPathToCommonAncestor(remoteRef.node()).slice(0, -1);
    return new ResetViewModel(nodes);
  }

  perform() {
    const context = this.graph.currentActionContext();
    const remoteRef = context.getRemoteRef(this.graph.currentRemote());
    return components.create('yesnodialog', { title: 'Are you sure?', details: 'Resetting to ref: ' + remoteRef.name + ' cannot be undone with ungit.'})
      .show()
      .closeThen((diag) => {
        if (!diag.result()) return;
        return this.server.postPromise('/reset', { path: this.graph.repoPath(), to: remoteRef.name, mode: 'hard' })
          .then(() => { context.node(remoteRef.node()); });
      }).closePromise;
  }
}


class Rebase extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Rebase', 'rebase', octicons['repo-forked'].toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      return this.graph.currentActionContext() instanceof RefViewModel &&
        (!ungit.config.showRebaseAndMergeOnlyOnRefs || this.node.refs().length > 0) &&
        this.graph.currentActionContext().current() &&
        this.graph.currentActionContext().node() != this.node;
    });
  }

  createHoverGraphic() {
    let onto = this.graph.currentActionContext();
    if (!onto) return;
    if (onto instanceof RefViewModel) onto = onto.node();
    const path = onto.getPathToCommonAncestor(this.node);
    return new RebaseViewModel(this.node, path);
  }

  perform() {
    return this.server.postPromise('/rebase', { path: this.graph.repoPath(), onto: this.node.sha1 })
      .catch((err) => { if (err.errorCode != 'merge-failed') this.server.unhandledRejection(err); });
  }
}


class Merge extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Merge', 'merge', octicons['git-merge'].toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      if (!this.graph.checkedOutRef() || !this.graph.checkedOutRef().node()) return false;
      return this.graph.currentActionContext() instanceof RefViewModel &&
        !this.graph.currentActionContext().current() &&
        this.graph.checkedOutRef().node() == this.node;
    });
  }

  createHoverGraphic() {
    let node = this.graph.currentActionContext();
    if (!node) return null;
    if (node instanceof RefViewModel) node = node.node();
    return new MergeViewModel(this.graph, this.node, node);
  }

  perform() {
    return this.server.postPromise('/merge', { path: this.graph.repoPath(), with: this.graph.currentActionContext().localRefName })
      .catch((err) => { if (err.errorCode != 'merge-failed') this.server.unhandledRejection(err); });
  }
}


class Push extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Push', 'push', octicons['repo-push'].toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      return this.graph.currentActionContext() instanceof RefViewModel &&
        this.graph.currentActionContext().node() == this.node &&
        this.graph.currentActionContext().canBePushed(this.graph.currentRemote());
    });
  }

  createHoverGraphic() {
    const context = this.graph.currentActionContext();
    if (!context) return null;
    const remoteRef = context.getRemoteRef(this.graph.currentRemote());
    if (!remoteRef) return null;
    return new PushViewModel(remoteRef.node(), context.node());
  }

  perform() {
    const ref = this.graph.currentActionContext();
    const remoteRef = ref.getRemoteRef(this.graph.currentRemote());

    if (remoteRef) {
      return remoteRef.moveTo(ref.node().sha1);
    } else {
      return ref.createRemoteRef().then(() => {
          if (this.graph.HEAD().name == ref.name) {
            this.grah.HEADref().node(ref.node());
          }
        }).finally(() => programEvents.dispatch({ event: 'request-fetch-tags' }));
    }
  }
}


class Checkout extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Checkout', 'checkout', octicons['desktop-download'].toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      if (this.graph.currentActionContext() instanceof RefViewModel)
        return this.graph.currentActionContext().node() == this.node &&
          !this.graph.currentActionContext().current();
      return ungit.config.allowCheckoutNodes &&
        this.graph.currentActionContext() == this.node;
    });
  }

  perform() {
    return this.graph.currentActionContext().checkout();
  }
}


class Delete extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Delete', 'delete', octicons.x.toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      return this.graph.currentActionContext() instanceof RefViewModel &&
        this.graph.currentActionContext().node() == this.node &&
        !this.graph.currentActionContext().current();
    });
  }

  perform() {
    const context = this.graph.currentActionContext();
    let details = `"${context.refName}"`;
    if (context.isRemoteBranch) {
      details = `<code _style="font-size: 100%">REMOTE</code> ${details}`;
    }
    details = `Deleting ${details} branch or tag cannot be undone with ungit.`;

    return components.create('yesnodialog', { title: 'Are you sure?', details: details })
      .show()
      .closeThen((diag) => {
        if (diag.result()) return context.remove();
      }).closePromise;
  }
}


class CherryPick extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Cherry pick', 'cherry-pick', octicons['circuit-board'].toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      const context = this.graph.currentActionContext();
      return context === this.node && this.graph.HEAD() && context.sha1 !== this.graph.HEAD().sha1;
    });
  }

  perform() {
    return this.server.postPromise('/cherrypick', { path: this.graph.repoPath(), name: this.node.sha1 })
      .catch((err) => { if (err.errorCode != 'merge-failed') this.server.unhandledRejection(err); });
  }
}


class Uncommit extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Uncommit', 'uncommit', octicons.zap.toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      return this.graph.currentActionContext() == this.node &&
        this.graph.HEAD() == this.node;
    });
  }

  perform() {
    return this.server.postPromise('/reset', { path: this.graph.repoPath(), to: 'HEAD^', mode: 'mixed' })
      .then(() => {
        let targetNode = this.node.belowNode;
        while (targetNode && !targetNode.ancestorOfHEAD()) {
          targetNode = targetNode.belowNode;
        }
        this.graph.HEADref().node(targetNode ? targetNode : null);
        this.graph.checkedOutRef().node(targetNode ? targetNode : null);
      });
  }
}


class Revert extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Revert', 'revert', octicons.history.toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      return this.graph.currentActionContext() == this.node;
    });
  }

  perform() {
    return this.server.postPromise('/revert', { path: this.graph.repoPath(), commit: this.node.sha1 });
  }
}


class Squash extends ActionBase {
  constructor(graph, node) {
    super(graph, 'Squash', 'squash', octicons.fold.toSVG({ 'height': 18 }));
    this.node = node;
    this.visible = ko.computed(() => {
      if (this.isRunning()) return true;
      return this.graph.currentActionContext() instanceof RefViewModel &&
        this.graph.currentActionContext().current() &&
        this.graph.currentActionContext().node() != this.node;
    });
  }

  createHoverGraphic() {
    let onto = this.graph.currentActionContext();
    if (!onto) return;
    if (onto instanceof RefViewModel) onto = onto.node();

    return new SquashViewModel(this.node, onto);
  }

  perform() {
    let onto = this.graph.currentActionContext();
    if (!onto) return;
    if (onto instanceof RefViewModel) onto = onto.node();
    // remove last element as it would be a common ancestor.
    const path = this.node.getPathToCommonAncestor(onto).slice(0, -1);

    if (path.length > 0) {
      // squashing branched out lineage
      // c is checkout with squash target of e, results in staging changes
      // from d and e on top of c
      //
      // a - b - (c)        a - b - (c) - [de]
      //  \           ->     \
      //   d  - <e>           d - <e>
      return this.server.postPromise('/squash', { path: this.graph.repoPath(), target: this.node.sha1 });
    } else {
      // squashing backward from same lineage
      // c is checkout with squash target of a, results in current ref moved
      // to a and staging changes within b and c on top of a
      //
      // <a> - b - (c)       (a) - b - c
      //                ->     \
      //                        [bc]
      return this.graph.currentActionContext().moveTo(this.node.sha1, true)
        .then(() => this.server.postPromise('/squash', { path: this.graph.repoPath(), target: onto.sha1 }));
    }
  }
}


const GraphActions = {
  Move: Move,
  Rebase: Rebase,
  Merge: Merge,
  Push: Push,
  Reset: Reset,
  Checkout: Checkout,
  Delete: Delete,
  CherryPick: CherryPick,
  Uncommit: Uncommit,
  Revert: Revert,
  Squash: Squash,
};
module.exports = GraphActions;

},{"./git-ref.js":5,"./hover-actions":7,"knockout":"knockout","octicons":undefined,"ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],4:[function(require,module,exports){
const $ = require('jquery');
const ko = require('knockout');
const components = require('ungit-components');
const programEvents = require('ungit-program-events');
const Animateable = require('./animateable');
const GraphActions = require('./git-graph-actions');

const maxBranchesToDisplay = parseInt(ungit.config.numRefsToShow / 5 * 3);  // 3/5 of refs to show to branches
const maxTagsToDisplay = ungit.config.numRefsToShow - maxBranchesToDisplay; // 2/5 of refs to show to tags

class GitNodeViewModel extends Animateable {
  constructor(graph, sha1) {
    super(graph);
    this.graph = graph;
    this.sha1 = sha1;
    this.isInited = false;
    this.title = ko.observable();
    this.parents = ko.observableArray();
    this.commitTime = undefined; // commit time in string
    this.date = undefined;       // commit time in numeric format for sort
    this.color = ko.observable();
    this.ideologicalBranch = ko.observable();
    this.remoteTags = ko.observableArray();
    this.branchesAndLocalTags = ko.observableArray();
    this.signatureDate = ko.observable();
    this.signatureMade = ko.observable();
    this.pgpVerifiedString = ko.computed(() => {
      if (this.signatureMade()) {
        return `PGP by: ${this.signatureMade()} at ${this.signatureDate()}`;
      }
    });

    this.refs = ko.computed(() => {
      const rs = this.branchesAndLocalTags().concat(this.remoteTags());
      rs.sort((a, b) => {
        if (b.current()) return 1;
        if (a.current()) return -1;
        if (a.isLocal && !b.isLocal) return -1;
        if (!a.isLocal && b.isLocal) return 1;
        return a.refName < b.refName ? -1 : 1;
      });
      return rs;
    });
    // These are split up like this because branches and local tags can be found in the git log,
    // whereas remote tags needs to be fetched with another command (which is much slower)
    this.branches = ko.observableArray();
    this.branchesToDisplay = ko.observableArray();
    this.tags = ko.observableArray();
    this.tagsToDisplay = ko.observableArray();
    this.refs.subscribe((newValue) => {
      if (newValue) {
        this.branches(newValue.filter((r) => r.isBranch));
        this.tags(newValue.filter((r) => r.isTag));
        this.tagsToDisplay(this.tags.slice(0, maxTagsToDisplay));
        this.branchesToDisplay(this.branches.slice(0, ungit.config.numRefsToShow - this.tagsToDisplay().length));
      } else {
        this.branches.removeAll();
        this.tags.removeAll();
        this.branchesToDisplay.removeAll();
        this.tagsToDisplay.removeAll();
      }
    });
    this.ancestorOfHEAD = ko.observable(false);
    this.nodeIsMousehover = ko.observable(false);
    this.commitContainerVisible = ko.computed(() => this.ancestorOfHEAD() || this.nodeIsMousehover() || this.selected());
    this.isEdgeHighlighted = ko.observable(false);
    // for small empty black circle to highlight a node
    this.isNodeAccented = ko.computed(() => this.selected() || this.isEdgeHighlighted());
    // to show changed files and diff boxes on the left of node
    this.highlighted = ko.computed(() => this.nodeIsMousehover() || this.selected());
    this.selected.subscribe(() => {
      programEvents.dispatch({ event: 'graph-render' });
    });
    this.showNewRefAction = ko.computed(() => !graph.currentActionContext());
    this.newBranchName = ko.observable();
    this.newBranchNameHasFocus = ko.observable(true);
    this.branchingFormVisible = ko.observable(false);
    this.canCreateRef = ko.computed(() => this.newBranchName() && this.newBranchName().trim() && !this.newBranchName().includes(' '));
    this.branchOrder = ko.observable();
    this.aboveNode = undefined;
    this.belowNode = undefined;
    this.refSearchFormVisible = ko.observable(false);
    this.commitComponent = components.create('commit', this);
    this.r = ko.observable();
    this.cx = ko.observable();
    this.cy = ko.observable();

    this.dropareaGraphActions = [
      new GraphActions.Move(this.graph, this),
      new GraphActions.Rebase(this.graph, this),
      new GraphActions.Merge(this.graph, this),
      new GraphActions.Push(this.graph, this),
      new GraphActions.Reset(this.graph, this),
      new GraphActions.Checkout(this.graph, this),
      new GraphActions.Delete(this.graph, this),
      new GraphActions.CherryPick(this.graph, this),
      new GraphActions.Uncommit(this.graph, this),
      new GraphActions.Revert(this.graph, this),
      new GraphActions.Squash(this.graph, this)
    ];
  }

  getGraphAttr() {
    return [this.cx(), this.cy()];
  }

  setGraphAttr(val) {
    this.element().setAttribute('x', val[0] - 30);
    this.element().setAttribute('y', val[1] - 30);
  }

  render() {
    this.refSearchFormVisible(false);
    if (!this.isInited) return;
    if (this.ancestorOfHEAD()) {
      this.r(30);
      this.cx(610);

      if (!this.aboveNode) {
        this.cy(120);
      } else if (this.aboveNode.ancestorOfHEAD()) {
        this.cy(this.aboveNode.cy() + 120);
      } else {
        this.cy(this.aboveNode.cy() + 60);
      }
    } else {
      this.r(15);
      this.cx(610 + (90 * this.branchOrder()));
      this.cy(this.aboveNode ? this.aboveNode.cy() + 60 : 120);
    }

    if (this.aboveNode && this.aboveNode.selected()) {
      this.cy(this.aboveNode.cy() + this.aboveNode.commitComponent.element().offsetHeight + 30);
    }

    this.color(this.ideologicalBranch() ? this.ideologicalBranch().color : '#666');
    this.animate();
  }

  setData(logEntry) {
    this.title(logEntry.message.split('\n')[0]);
    this.parents(logEntry.parents || []);
    this.commitTime = logEntry.commitDate;
    this.date = Date.parse(this.commitTime);
    this.commitComponent.setData(logEntry);
    this.signatureMade(logEntry.signatureMade);
    this.signatureDate(logEntry.signatureDate);

    (logEntry.refs || []).forEach(ref => {
      this.graph.getRef(ref).node(this);
    });
    this.isInited = true;
  }

  showBranchingForm() {
    this.branchingFormVisible(true);
    this.newBranchNameHasFocus(true);
  }

  showRefSearchForm(obj, event) {
    this.refSearchFormVisible(true);

    const textBox = event.currentTarget.nextElementSibling.firstElementChild; // this may not be the best idea...
    $(textBox).autocomplete({
      source: this.refs().filter(ref => !ref.isHEAD),
      minLength: 0,
      select: (event, ui) => {
        const ref = ui.item;
        const ray = ref.isTag ? this.tagsToDisplay : this.branchesToDisplay;

        // if ref is in display, remove it, else remove last in array.
        ray.splice(ray.indexOf(ref), 1);
        ray.unshift(ref);
        this.refSearchFormVisible(false);
      },
      messages: {
        noResults: '',
        results: () => {}
      }
    }).focus(() => {
      $(this).autocomplete('search', $(this).val());
    }).data('ui-autocomplete')._renderItem = (ul, item) => $('<li></li>')
      .append(`<a>${item.dom}</a>`)
      .appendTo(ul);
    $(textBox).autocomplete('search', '');
  }

  createBranch() {
    if (!this.canCreateRef()) return;
    this.graph.server.postPromise('/branches', { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
      .then(() => {
        this.graph.getRef(`refs/heads/${this.newBranchName()}`).node(this);
        if (ungit.config.autoCheckoutOnBranchCreate) {
          return this.graph.server.postPromise('/checkout', { path: this.graph.repoPath(), name: this.newBranchName() });
        }
      }).catch((e) => this.graph.server.unhandledRejection(e))
      .finally(() => {
        this.branchingFormVisible(false);
        this.newBranchName('');
        programEvents.dispatch({ event: 'branch-updated' });
      });
  }

  createTag() {
    if (!this.canCreateRef()) return;
    this.graph.server.postPromise('/tags', { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
      .then(() => this.graph.getRef(`refs/tags/${this.newBranchName()}`).node(this) )
      .catch((e) => this.graph.server.unhandledRejection(e))
      .finally(() => {
        this.branchingFormVisible(false);
        this.newBranchName('');
      });
  }

  toggleSelected() {
    const beforeThisCR = this.commitComponent.element().getBoundingClientRect();
    let beforeBelowCR = null;
    if (this.belowNode) {
      beforeBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
    }

    let prevSelected  = this.graph.currentActionContext();
    if (!(prevSelected instanceof GitNodeViewModel)) prevSelected = null;
    const prevSelectedCR = prevSelected ? prevSelected.commitComponent.element().getBoundingClientRect() : null;
    this.selected(!this.selected());

    // If we are deselecting
    if (!this.selected()) {
      if (beforeThisCR.top < 0 && beforeBelowCR) {
        const afterBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
        // If the next node is showing, try to keep it in the screen (no jumping)
        if (beforeBelowCR.top < window.innerHeight) {
          window.scrollBy(0, afterBelowCR.top - beforeBelowCR.top);
        // Otherwise just try to bring them to the middle of the screen
        } else {
          window.scrollBy(0, afterBelowCR.top - window.innerHeight / 2);
        }
      }
    // If we are selecting
    } else {
      const afterThisCR = this.commitComponent.element().getBoundingClientRect();
      if ((prevSelectedCR && (prevSelectedCR.top < 0 || prevSelectedCR.top > window.innerHeight)) &&
        afterThisCR.top != beforeThisCR.top) {
        window.scrollBy(0, -(beforeThisCR.top - afterThisCR.top));
        console.log('Fix');
      }
    }
    return false;
  }

  removeRef(ref) {
    if (ref.isRemoteTag) {
      this.remoteTags.remove(ref);
    } else {
      this.branchesAndLocalTags.remove(ref);
    }
  }

  pushRef(ref) {
    if (ref.isRemoteTag && !this.remoteTags().includes(ref)) {
      this.remoteTags.push(ref);
    } else if(!this.branchesAndLocalTags().includes(ref)) {
      this.branchesAndLocalTags.push(ref);
    }
  }

  updateAnimationFrame(deltaT) {
    this.commitComponent.updateAnimationFrame(deltaT);
  }

  getPathToCommonAncestor(node) {
    const path = [];
    let thisNode = this;
    while (thisNode && !node.isAncestor(thisNode)) {
      path.push(thisNode);
      thisNode = this.graph.nodesById[thisNode.parents()[0]];
    }
    if (thisNode) path.push(thisNode);
    return path;
  }

  isAncestor(node) {
    if (node == this) return true;
    for (const v in this.parents()) {
      const n = this.graph.nodesById[this.parents()[v]];
      if (n && n.isAncestor(node)) return true;
    }
    return false;
  }

  getRightToLeftStrike() {
    return `M ${this.cx() - 30} ${this.cy() - 30} L ${this.cx() + 30} ${this.cy() + 30}`;
  }

  getLeftToRightStrike() {
    return `M ${this.cx() + 30} ${this.cy() - 30} L ${this.cx() - 30} ${this.cy() + 30}`;
  }

  nodeMouseover() {
    this.nodeIsMousehover(true);
  }

  nodeMouseout() {
    this.nodeIsMousehover(false);
  }

  isViewable() {
    return this.graph.nodes().includes(this);
  }
}

module.exports = GitNodeViewModel;

},{"./animateable":1,"./git-graph-actions":3,"jquery":undefined,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],5:[function(require,module,exports){
const ko = require('knockout');
const md5 = require('blueimp-md5');
const promise = require('bluebird');
const octicons = require('octicons');
const programEvents = require('ungit-program-events');
const components = require('ungit-components');
const Selectable = require('./selectable');

class RefViewModel extends Selectable {
  constructor(fullRefName, graph) {
    super(graph);
    this.graph = graph;
    this.name = fullRefName;
    this.node = ko.observable();
    this.localRefName = this.name; // origin/master or master
    this.refName = this.name; // master
    this.isRemoteTag = this.name.indexOf('remote-tag: ') == 0;
    this.isLocalTag = this.name.indexOf('tag: ') == 0;
    this.isTag = this.isLocalTag || this.isRemoteTag;
    const isRemoteBranchOrHEAD = this.name.indexOf('refs/remotes/') == 0;
    this.isLocalHEAD = this.name == 'HEAD';
    this.isRemoteHEAD = this.name.includes('/HEAD');
    this.isLocalBranch = this.name.indexOf('refs/heads/') == 0;
    this.isRemoteBranch = isRemoteBranchOrHEAD && !this.isRemoteHEAD;
    this.isStash = this.name.indexOf('refs/stash') == 0;
    this.isHEAD = this.isLocalHEAD || this.isRemoteHEAD;
    this.isBranch = this.isLocalBranch || this.isRemoteBranch;
    this.isRemote = isRemoteBranchOrHEAD || this.isRemoteTag;
    this.isLocal = this.isLocalBranch || this.isLocalTag;
    if (this.isLocalBranch) {
      this.localRefName = this.name.slice('refs/heads/'.length);
      this.refName = this.localRefName;
    }
    if (this.isRemoteBranch) {
      this.localRefName = this.name.slice('refs/remotes/'.length);
    }
    if (this.isLocalTag) {
      this.localRefName = this.name.slice('tag: refs/tags/'.length);
      this.refName = this.localRefName;
    }
    if (this.isRemoteTag) {
      this.localRefName = this.name.slice('remote-tag: '.length);
    }
    const splitedName = this.localRefName.split('/');
    if (this.isRemote) {
      // get rid of the origin/ part of origin/branchname
      this.remote = splitedName[0];
      this.refName = splitedName.slice(1).join('/');
    }
    this.show = true;
    this.server = this.graph.server;
    this.isDragging = ko.observable(false);
    this.current = ko.computed(() => this.isLocalBranch && this.graph.checkedOutBranch() == this.refName);
    this.color = this._colorFromHashOfString(this.name);

    this.node.subscribe(oldNode => {
      if (oldNode) oldNode.removeRef(this);
    }, null, 'beforeChange');
    this.node.subscribe(newNode => {
      if (newNode) newNode.pushRef(this);
    });

    // This optimization is for autocomplete display
    this.value = splitedName[splitedName.length - 1];
    this.label = this.localRefName;
    this.dom = `${this.localRefName}<span>${octicons[(this.isTag ? 'tag': 'git-branch')].toSVG({ 'height': 18 })}</span>`;

    this.displayHtml = (largeCurrent) => {
      const size = (largeCurrent && this.current()) ? 26 : 18;
      let prefix = '';
      if (this.isRemote) {
        prefix = `<span>${octicons.globe.toSVG({ 'height': size })}</span> `;
      }
      if (this.isBranch) {
        prefix += `<span>${octicons['git-branch'].toSVG({ 'height': size })}</span> `;
      } else if (this.isTag) {
        prefix += `<span>${octicons.tag.toSVG({ 'height': size })}</span> `;
      }
      return prefix + this.localRefName;
    };
  }

  _colorFromHashOfString(string) {
    return `#${md5(string).toString().slice(0, 6)}`;
  }

  dragStart() {
    this.graph.currentActionContext(this);
    this.isDragging(true);
    if (document.activeElement) document.activeElement.blur();
  }

  dragEnd() {
    this.graph.currentActionContext(null);
    this.isDragging(false);
  }

  moveTo(target, rewindWarnOverride) {
    let promise;
    if (this.isLocal) {
      const toNode = this.graph.nodesById[target];
      const args = { path: this.graph.repoPath(), name: this.refName, sha1: target, force: true, to: target, mode: 'hard' };
      let operation;
      if (this.current()) {
        operation = '/reset';
      } else if (this.isTag) {
        operation = '/tags';
      } else {
        operation = '/branches';
      }

      if (!rewindWarnOverride && this.node().date > toNode.date) {
        promise = components.create('yesnodialog', { title: 'Are you sure?', details: 'This operation potentially going back in history.'})
          .show()
          .closeThen(diag => {
            if (diag.result()) {
              return this.server.postPromise(operation, args);
            }
          }).closePromise;
      } else {
        promise = this.server.postPromise(operation, args);
      }
    } else {
      const pushReq = { path: this.graph.repoPath(), remote: this.remote, refSpec: target, remoteBranch: this.refName };
      promise = this.server.postPromise('/push', pushReq)
        .catch(err => {
          if (err.errorCode === 'non-fast-forward') {
            return components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' })
              .show()
              .closeThen(diag => {
                if (!diag.result()) return false;
                pushReq.force = true;
                return this.server.postPromise('/push', pushReq);
              }).closePromise;
          } else {
            this.server.unhandledRejection(err);
          }
        });
    }

    return promise
      .then(res => {
        if (!res) return;
        const targetNode = this.graph.getNode(target);
        if (this.graph.checkedOutBranch() == this.refName) {
          this.graph.HEADref().node(targetNode);
        }
        this.node(targetNode);
      }).catch((e) => this.server.unhandledRejection(e));
  }

  remove(isClientOnly) {
    let url = this.isTag ? '/tags' : '/branches';
    if (this.isRemote) url = `/remote${url}`;

    return (isClientOnly ? promise.resolve() : this.server.delPromise(url, { path: this.graph.repoPath(), remote: this.isRemote ? this.remote : null, name: this.refName }))
      .then(() => {
        if (this.node()) this.node().removeRef(this);
        this.graph.refs.remove(this);
        delete this.graph.refsByRefName[this.name];
      }).catch((e) => this.server.unhandledRejection(e))
      .finally(() => {
        if (!isClientOnly) {
          if (url == '/remote/tags') {
            programEvents.dispatch({ event: 'request-fetch-tags' });
          } else {
            programEvents.dispatch({ event: 'branch-updated' });
          }
        }
      });
  }

  getLocalRef() {
    return this.graph.getRef(this.getLocalRefFullName(), false);
  }

  getLocalRefFullName() {
    if (this.isRemoteBranch) return `refs/heads/${this.refName}`;
    if (this.isRemoteTag) return `tag: ${this.refName}`;
    return null;
  }

  getRemoteRef(remote) {
    return this.graph.getRef(this.getRemoteRefFullName(remote), false);
  }

  getRemoteRefFullName(remote) {
    if (this.isLocalBranch) return `refs/remotes/${remote}/${this.refName}`;
    if (this.isLocalTag) return `remote-tag: ${remote}/${this.refName}`;
    return null;
  }

  canBePushed(remote) {
    if (!this.isLocal) return false;
    if (!remote) return false;
    const remoteRef = this.getRemoteRef(remote);
    if (!remoteRef) return true;
    return this.node() != remoteRef.node();
  }

  createRemoteRef() {
    return this.server.postPromise('/push', { path: this.graph.repoPath(), remote: this.graph.currentRemote(), refSpec: this.refName, remoteBranch: this.refName })
      .catch((e) => this.server.unhandledRejection(e));
  }

  checkout() {
    const isRemote = this.isRemoteBranch;
    const isLocalCurrent = this.getLocalRef() && this.getLocalRef().current();

    return promise.resolve().then(() => {
        if (isRemote && !isLocalCurrent) {
          return this.server.postPromise('/branches', {
            path: this.graph.repoPath(),
            name: this.refName,
            sha1: this.name,
            force: true
          });
        }
      }).then(() => this.server.postPromise('/checkout', { path: this.graph.repoPath(), name: this.refName }))
      .then(() => {
        if (isRemote && isLocalCurrent) {
          return this.server.postPromise('/reset', { path: this.graph.repoPath(), to: this.name, mode: 'hard' });
        }
      }).then(() => {
        this.graph.HEADref().node(this.node());
      }).catch((err) => {
        if (err.errorCode != 'merge-failed') this.server.unhandledRejection(err);
      });
  }
}

module.exports = RefViewModel;

},{"./selectable":8,"bluebird":undefined,"blueimp-md5":"blueimp-md5","knockout":"knockout","octicons":undefined,"ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],6:[function(require,module,exports){
const ko = require('knockout');
const _ = require('lodash');
const moment = require('moment');
const octicons = require('octicons');
const components = require('ungit-components');
const programEvents = require('ungit-program-events');
const GitNodeViewModel = require('./git-node');
const GitRefViewModel = require('./git-ref');
const EdgeViewModel = require('./edge');
const numberOfNodesPerLoad = ungit.config.numberOfNodesPerLoad;

components.register('graph', args => new GraphViewModel(args.server, args.repoPath));

class GraphViewModel {
  constructor(server, repoPath) {
    this._markIdeologicalStamp = 0;
    this.repoPath = repoPath;
    this.limit = ko.observable(numberOfNodesPerLoad);
    this.skip = ko.observable(0);
    this.server = server;
    this.currentRemote = ko.observable();
    this.nodes = ko.observableArray();
    this.edges = ko.observableArray();
    this.refs = ko.observableArray();
    this.nodesById = {};
    this.refsByRefName = {};
    this.checkedOutBranch = ko.observable();
    this.checkedOutRef = ko.computed(() => this.checkedOutBranch() ? this.getRef(`refs/heads/${this.checkedOutBranch()}`) : null);
    this.HEADref = ko.observable();
    this.HEAD = ko.computed(() => this.HEADref() ? this.HEADref().node() : undefined);
    this.commitNodeColor = ko.computed(() => this.HEAD() ? this.HEAD().color() : '#4A4A4A');
    this.commitNodeEdge = ko.computed(() => {
      if (!this.HEAD() || !this.HEAD().cx() || !this.HEAD().cy()) return;
      return `M 610 68 L ${this.HEAD().cx()} ${this.HEAD().cy()}`;
    });
    this.showCommitNode = ko.observable(false);
    this.currentActionContext = ko.observable();
    this.edgesById = {};
    this.scrolledToEnd = _.debounce(() => {
      this.limit(numberOfNodesPerLoad + this.limit());
      this.loadNodesFromApi();
    }, 500, true);
    this.loadAhead = _.debounce(() => {
      if (this.skip() <= 0) return;
      this.skip(Math.max(this.skip() - numberOfNodesPerLoad, 0));
      this.loadNodesFromApi();
    }, 500, true);
    this.commitOpacity = ko.observable(1.0);
    this.heighstBranchOrder = 0;
    this.hoverGraphActionGraphic = ko.observable();
    this.hoverGraphActionGraphic.subscribe(value => {
      if (value && value.destroy)
        value.destroy();
    }, null, 'beforeChange');

    this.hoverGraphAction = ko.observable();
    this.hoverGraphAction.subscribe(value => {
      if (value && value.createHoverGraphic) {
        this.hoverGraphActionGraphic(value.createHoverGraphic());
      } else {
        this.hoverGraphActionGraphic(null);
      }
    });

    this.loadNodesFromApiThrottled = _.throttle(this.loadNodesFromApi.bind(this), 1000);
    this.updateBranchesThrottled = _.throttle(this.updateBranches.bind(this), 1000);
    this.loadNodesFromApi();
    this.updateBranches();
    this.graphWidth = ko.observable();
    this.graphHeight = ko.observable(800);
    this.searchIcon = octicons.search.toSVG({ 'height': 18 });
    this.plusIcon = octicons.plus.toSVG({ 'height': 18 });
  }

  updateNode(parentElement) {
    ko.renderTemplate('graph', this, {}, parentElement);
  }

  getNode(sha1, logEntry) {
    let nodeViewModel = this.nodesById[sha1];
    if (!nodeViewModel) nodeViewModel = this.nodesById[sha1] = new GitNodeViewModel(this, sha1);
    if (logEntry) nodeViewModel.setData(logEntry);
    return nodeViewModel;
  }

  getRef(ref, constructIfUnavailable) {
    if (constructIfUnavailable === undefined) constructIfUnavailable = true;
    let refViewModel = this.refsByRefName[ref];
    if (!refViewModel && constructIfUnavailable) {
      refViewModel = this.refsByRefName[ref] = new GitRefViewModel(ref, this);
      this.refs.push(refViewModel);
      if (refViewModel.name === 'HEAD') {
        this.HEADref(refViewModel);
      }
    }
    return refViewModel;
  }

  loadNodesFromApi() {
    const nodeSize = this.nodes().length;

    return this.server.getPromise('/gitlog', { path: this.repoPath(), limit: this.limit(), skip: this.skip() })
      .then(log => {
        // set new limit and skip
        this.limit(parseInt(log.limit));
        this.skip(parseInt(log.skip));
        return log.nodes || [];
      }).then(nodes => // create and/or calculate nodes
    this.computeNode(nodes.map((logEntry) => {
      return this.getNode(logEntry.sha1, logEntry);     // convert to node object
    }))).then(nodes => {
        // create edges
        const edges = [];
        nodes.forEach(node => {
          node.parents().forEach(parentSha1 => {
            edges.push(this.getEdge(node.sha1, parentSha1));
          });
          node.render();
        });

        this.edges(edges);
        this.nodes(nodes);
        if (nodes.length > 0) {
          this.graphHeight(nodes[nodes.length - 1].cy() + 80);
        }
        this.graphWidth(1000 + (this.heighstBranchOrder * 90));
        programEvents.dispatch({ event: 'init-tooltip' });
      }).catch((e) => this.server.unhandledRejection(e))
      .finally(() => {
        if (window.innerHeight - this.graphHeight() > 0 && nodeSize != this.nodes().length) {
          this.scrolledToEnd();
        }
      });
  }

  traverseNodeLeftParents(node, callback) {
    callback(node);
    const parent = this.nodesById[node.parents()[0]];
    if (parent) {
      this.traverseNodeLeftParents(parent, callback);
    }
  }

  computeNode(nodes) {
    nodes = nodes || this.nodes();

    this.markNodesIdeologicalBranches(this.refs(), nodes, this.nodesById);

    const updateTimeStamp = moment().valueOf();
    if (this.HEAD()) {
      this.traverseNodeLeftParents(this.HEAD(), node => {
        node.ancestorOfHEADTimeStamp = updateTimeStamp;
      });
    }

    // Filter out nodes which doesn't have a branch (staging and orphaned nodes)
    nodes = nodes.filter(node => (node.ideologicalBranch() && !node.ideologicalBranch().isStash) || node.ancestorOfHEADTimeStamp == updateTimeStamp);

    let branchSlotCounter = this.HEAD() ? 1 : 0;

    // Then iterate from the bottom to fix the orders of the branches
    for (let i = nodes.length - 1; i >= 0; i--) {
      const node = nodes[i];
      if (node.ancestorOfHEADTimeStamp == updateTimeStamp) continue;
      const ideologicalBranch = node.ideologicalBranch();

      // First occurrence of the branch, find an empty slot for the branch
      if (ideologicalBranch.lastSlottedTimeStamp != updateTimeStamp) {
        ideologicalBranch.lastSlottedTimeStamp = updateTimeStamp;
        ideologicalBranch.branchOrder = branchSlotCounter++;
      }

      node.branchOrder(ideologicalBranch.branchOrder);
    }

    this.heighstBranchOrder = branchSlotCounter - 1;
    let prevNode;
    nodes.forEach(node => {
      node.ancestorOfHEAD(node.ancestorOfHEADTimeStamp == updateTimeStamp);
      if (node.ancestorOfHEAD()) node.branchOrder(0);
      node.aboveNode = prevNode;
      if (prevNode) prevNode.belowNode = node;
      prevNode = node;
    });

    return nodes;
  }

  getEdge(nodeAsha1, nodeBsha1) {
    const id = `${nodeAsha1}-${nodeBsha1}`;
    let edge = this.edgesById[id];
    if (!edge) {
      edge = this.edgesById[id] = new EdgeViewModel(this, nodeAsha1, nodeBsha1);
    }
    return edge;
  }

  markNodesIdeologicalBranches(refs, nodes, nodesById) {
    refs = refs.filter(r => !!r.node());
    refs = refs.sort((a, b) => {
      if (a.isLocal && !b.isLocal) return -1;
      if (b.isLocal && !a.isLocal) return 1;
      if (a.isBranch && !b.isBranch) return -1;
      if (b.isBranch && !a.isBranch) return 1;
      if (a.isHEAD && !b.isHEAD) return 1;
      if (!a.isHEAD && b.isHEAD) return -1;
      if (a.isStash && !b.isStash) return 1;
      if (b.isStash && !a.isStash) return -1;
      if (a.node() && a.node().date && b.node() && b.node().date)
        return a.node().date - b.node().date;
      return a.refName < b.refName ? -1 : 1;
    });
    const stamp = this._markIdeologicalStamp++;
    refs.forEach(ref => {
      this.traverseNodeParents(ref.node(), node => {
        if (node.stamp == stamp) return false;
        node.stamp = stamp;
        node.ideologicalBranch(ref);
        return true;
      });
    });
  }

  traverseNodeParents(node, callback) {
    if (!callback(node)) return false;
    for (let i = 0; i < node.parents().length; i++) {
      // if parent, travers parent
      const parent = this.nodesById[node.parents()[i]];
      if (parent) {
        this.traverseNodeParents(parent, callback);
      }
    }
  }

  handleBubbledClick(elem, event) {
    // If the clicked element is bound to the current action context,
    // then let's not deselect it.
    if (ko.dataFor(event.target) === this.currentActionContext()) return;
    if (this.currentActionContext() && this.currentActionContext() instanceof GitNodeViewModel) {
      this.currentActionContext().toggleSelected();
    } else {
      this.currentActionContext(null);
    }
    // If the click was on an input element, then let's allow the default action to proceed.
    // This is especially needed since for some strange reason any submit (ie. enter in a textbox)
    // will trigger a click event on the submit input of the form, which will end up here,
    // and if we don't return true, then the submit event is never fired, breaking stuff.
    if (event.target.nodeName === 'INPUT') return true;
  }

  onProgramEvent(event) {
    if (event.event == 'git-directory-changed') {
      this.loadNodesFromApiThrottled();
      this.updateBranchesThrottled();
    } else if (event.event == 'request-app-content-refresh') {
      this.loadNodesFromApiThrottled();
    } else if (event.event == 'remote-tags-update') {
      this.setRemoteTags(event.tags);
    } else if (event.event == 'current-remote-changed') {
      this.currentRemote(event.newRemote);
    } else if (event.event == 'graph-render') {
      this.nodes().forEach(node => {
        node.render();
      });
    }
  }

  updateAnimationFrame(deltaT) {
    this.nodes().forEach(node => {
      node.updateAnimationFrame(deltaT);
    });
  }

  updateBranches() {
    this.server.getPromise('/checkout', { path: this.repoPath() })
      .then(res => { this.checkedOutBranch(res); })
      .catch(err => {
        if (err.errorCode != 'not-a-repository') this.server.unhandledRejection(err);
      });
  }

  setRemoteTags(remoteTags) {
    const version = Date.now();

    const sha1Map = {}; // map holding true sha1 per tags
    remoteTags.forEach(tag => {
      if (tag.name.includes('^{}')) {
        // This tag is a dereference tag, use this sha1.
        const tagRef = tag.name.slice(0, tag.name.length - '^{}'.length);
        sha1Map[tagRef] = tag.sha1;
      } else if (!sha1Map[tag.name]) {
        // If sha1 wasn't previously set, use this sha1
        sha1Map[tag.name] = tag.sha1;
      }
    });

    remoteTags.forEach((ref) => {
      if (!ref.name.includes('^{}')) {
        const name = `remote-tag: ${ref.remote}/${ref.name.split('/')[2]}`;
        this.getRef(name).node(this.getNode(sha1Map[ref.name]));
        this.getRef(name).version = version;
      }
    });
    this.refs().forEach((ref) => {
      // tag is removed from another source
      if (ref.isRemoteTag && (!ref.version || ref.version < version)) {
        ref.remove(true);
      }
    });
  }

  checkHeadMove(toNode) {
    if (this.HEAD() === toNode) {
      this.HEADref.node(toNode);
    }
  }
}

},{"./edge":2,"./git-node":4,"./git-ref":5,"knockout":"knockout","lodash":"lodash","moment":"moment","octicons":undefined,"ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],7:[function(require,module,exports){
const getEdgeModelWithD = (d, stroke, strokeWidth, strokeDasharray, markerEnd) => ({
  d,
  stroke: stroke ? stroke : '#4A4A4A',
  strokeWidth: strokeWidth ? strokeWidth : '8',
  strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5',
  markerEnd: markerEnd ? markerEnd : ''
});
const getEdgeModel = (scx, scy, tcx, tcy, stroke, strokeWidth, strokeDasharray, markerEnd) => {
  return getEdgeModelWithD(`M ${scx} ${scy} L ${tcx} ${tcy}`, stroke, strokeWidth, strokeDasharray, markerEnd);
}
const getNodeModel = (cx, cy, r, fill, stroke, strokeWidth, strokeDasharray) => ({
  cx,
  cy,
  r,
  fill,
  stroke: stroke ? stroke : '#41DE3C',
  strokeWidth: strokeWidth ? strokeWidth : '8',
  strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5'
});

class HoverViewModel {
  constructor() {
    this.bgEdges = [];
    this.nodes = [];
    this.fgEdges = [];
  }
}

class MergeViewModel extends HoverViewModel {
  constructor(graph, headNode, node) {
    super();
    this.graph = graph;
    this.bgEdges = [ getEdgeModel(headNode.cx(), (headNode.cy() - 110), headNode.cx(), headNode.cy()),
                  getEdgeModel(headNode.cx(), (headNode.cy() - 110), node.cx(), node.cy()) ];
    this.nodes = [ getNodeModel(headNode.cx(), headNode.cy() - 110, Math.max(headNode.r(), node.r()), '#252833', '#41DE3C', '8', '10, 5') ];

    graph.commitOpacity(0.1);
  }

  destroy() {
    this.graph.commitOpacity(1.0);
  }
}

exports.MergeViewModel = MergeViewModel;

class RebaseViewModel extends HoverViewModel {
  constructor(onto, nodesThatWillMove) {
    super();
    nodesThatWillMove = nodesThatWillMove.slice(0, -1);

    if (nodesThatWillMove.length == 0) return;

    this.bgEdges.push(getEdgeModel(onto.cx(), onto.cy(), onto.cx(), onto.cy() - 60));
    nodesThatWillMove.forEach((node, i) => {
      const cy = onto.cy() + (-90 * (i + 1));
      this.nodes.push(getNodeModel(onto.cx(), cy, 28, 'transparent'));
      if (i + 1 < nodesThatWillMove.length) {
        this.bgEdges.push(getEdgeModel(onto.cx(), (cy - 25), onto.cx(), (cy - 65)));
      }
    });
  }
}
exports.RebaseViewModel = RebaseViewModel;

class ResetViewModel extends HoverViewModel {
  constructor(nodes) {
    super();
    nodes.forEach(node => {
      this.fgEdges.push(getEdgeModelWithD(node.getLeftToRightStrike(), 'rgb(255, 129, 31)', '8', '0, 0'))
      this.fgEdges.push(getEdgeModelWithD(node.getRightToLeftStrike(), 'rgb(255, 129, 31)', '8', '0, 0'));
    });
  }
}
exports.ResetViewModel = ResetViewModel;

class PushViewModel extends HoverViewModel {
    constructor(fromNode, toNode) {
    super();
    this.fgEdges = [getEdgeModel(fromNode.cx(), fromNode.cy(), toNode.cx(), (toNode.cy() + 40), 'rgb(61, 139, 255)', '15', '10, 5', 'url(#pushArrowEnd)' )];
  }
}
exports.PushViewModel = PushViewModel;

class SquashViewModel extends HoverViewModel {
  constructor(from, onto) {
    super();
    let path = from.getPathToCommonAncestor(onto);

    if (path.length == 0) {
      return;
    } else if (path.length == 1) {
      path = onto.getPathToCommonAncestor(from)
    } else {
      this.nodes.push(getNodeModel(onto.cx(), onto.cy() - 120, 28, 'transparent'));
    }

    path.slice(0, -1).forEach((node) => {
      this.nodes.push(getNodeModel(node.cx(), node.cy(), node.r() + 2, 'rgba(100, 60, 222, 0.8)'));
    });
  }
}
exports.SquashViewModel = SquashViewModel;

},{}],8:[function(require,module,exports){
var ko = require('knockout');

class Selectable {
  constructor(graph) {
    this.selected = ko.computed({
      read() {
        return graph.currentActionContext() == this;
      },
      write(val) {
        // val is this if we're called from a click ko binding
        if (val === this || val === true) {
          graph.currentActionContext(this);
        } else if (graph.currentActionContext() == this) {
          graph.currentActionContext(null);
        }
      },
      owner: this
    });
  }
}
module.exports = Selectable;

},{"knockout":"knockout"}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2FuaW1hdGVhYmxlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9lZGdlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9naXQtZ3JhcGgtYWN0aW9ucy5qcyIsImNvbXBvbmVudHMvZ3JhcGgvZ2l0LW5vZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2dpdC1yZWYuanMiLCJjb21wb25lbnRzL2dyYXBoL2dyYXBoLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ob3Zlci1hY3Rpb25zLmpzIiwiY29tcG9uZW50cy9ncmFwaC9zZWxlY3RhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY29uc3Qga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuY29uc3QgU2VsZWN0YWJsZSA9IHJlcXVpcmUoJy4vc2VsZWN0YWJsZScpO1xuXG5yZXF1aXJlKCdtaW5hJyk7XG5cbmNsYXNzIEFuaW1hdGVhYmxlIGV4dGVuZHMgU2VsZWN0YWJsZSB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoKSB7XG4gICAgc3VwZXIoZ3JhcGgpO1xuICAgIHRoaXMuZWxlbWVudCA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLnByZXZpb3VzR3JhcGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbGVtZW50LnN1YnNjcmliZSh2YWwgPT4ge1xuICAgICAgaWYgKHZhbCkgdGhpcy5hbmltYXRlKHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuYW5pbWF0ZSA9IChmb3JjZVJlZnJlc2gpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRHcmFwaCA9IHRoaXMuZ2V0R3JhcGhBdHRyKCk7XG4gICAgICBpZiAodGhpcy5lbGVtZW50KCkgJiYgKGZvcmNlUmVmcmVzaCB8fCBKU09OLnN0cmluZ2lmeShjdXJyZW50R3JhcGgpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLnByZXZpb3VzR3JhcGgpKSkge1xuICAgICAgICAvLyBkb20gaXMgdmFsaWQgYW5kIGZvcmNlIHJlZnJlc2ggaXMgcmVxdWVzdGVkIG9yIGRvbSBtb3ZlZCwgcmVkcmF3XG4gICAgICAgIGlmICh1bmdpdC5jb25maWcuaXNBbmltYXRlKSB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB3aW5kb3cubWluYSh0aGlzLnByZXZpb3VzR3JhcGggfHwgY3VycmVudEdyYXBoLCBjdXJyZW50R3JhcGgsIG5vdywgbm93ICsgNzUwLCB3aW5kb3cubWluYS50aW1lLCB2YWwgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRHcmFwaEF0dHIodmFsKTtcbiAgICAgICAgICB9LCB3aW5kb3cubWluYS5lbGFzdGljKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldEdyYXBoQXR0cihjdXJyZW50R3JhcGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldmlvdXNHcmFwaCA9IGN1cnJlbnRHcmFwaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0ZWFibGU7XG4iLCJjb25zdCBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5jb25zdCBBbmltYXRlYWJsZSA9IHJlcXVpcmUoJy4vYW5pbWF0ZWFibGUnKTtcblxuY2xhc3MgRWRnZVZpZXdNb2RlbCBleHRlbmRzIEFuaW1hdGVhYmxlIHtcbiAgY29uc3RydWN0b3IoZ3JhcGgsIG5vZGVBc2hhMSwgbm9kZUJzaGExKSB7XG4gICAgc3VwZXIoZ3JhcGgpO1xuICAgIHRoaXMubm9kZUEgPSBncmFwaC5nZXROb2RlKG5vZGVBc2hhMSk7XG4gICAgdGhpcy5ub2RlQiA9IGdyYXBoLmdldE5vZGUobm9kZUJzaGExKTtcbiAgICB0aGlzLmdldEdyYXBoQXR0ciA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLm5vZGVBLmlzVmlld2FibGUoKSAmJiAoIXRoaXMubm9kZUIuaXNWaWV3YWJsZSgpIHx8ICF0aGlzLm5vZGVCLmlzSW5pdGVkKSkge1xuICAgICAgICByZXR1cm4gW3RoaXMubm9kZUEuY3goKSwgdGhpcy5ub2RlQS5jeSgpLCB0aGlzLm5vZGVBLmN4KCksIHRoaXMubm9kZUEuY3koKSxcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVBLmN4KCksIGdyYXBoLmdyYXBoSGVpZ2h0KCksIHRoaXMubm9kZUEuY3goKSwgZ3JhcGguZ3JhcGhIZWlnaHQoKV07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubm9kZUIuaXNJbml0ZWQgJiYgdGhpcy5ub2RlQi5jeCgpICYmIHRoaXMubm9kZUIuY3koKSkge1xuICAgICAgICByZXR1cm4gW3RoaXMubm9kZUEuY3goKSwgdGhpcy5ub2RlQS5jeSgpLCB0aGlzLm5vZGVBLmN4KCksIHRoaXMubm9kZUEuY3koKSxcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVCLmN4KCksIHRoaXMubm9kZUIuY3koKSwgdGhpcy5ub2RlQi5jeCgpLCB0aGlzLm5vZGVCLmN5KCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmdldEdyYXBoQXR0ci5zdWJzY3JpYmUodGhpcy5hbmltYXRlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc2V0R3JhcGhBdHRyKHZhbCkge1xuICAgIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnZCcsIGBNJHt2YWwuc2xpY2UoMCw0KS5qb2luKCcsJyl9TCR7dmFsLnNsaWNlKDQsOCkuam9pbignLCcpfWApO1xuICB9XG5cbiAgZWRnZU1vdXNlT3ZlcigpIHtcbiAgICBpZiAodGhpcy5ub2RlQSkge1xuICAgICAgdGhpcy5ub2RlQS5pc0VkZ2VIaWdobGlnaHRlZCh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubm9kZUIpIHtcbiAgICAgIHRoaXMubm9kZUIuaXNFZGdlSGlnaGxpZ2h0ZWQodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZWRnZU1vdXNlT3V0KCkge1xuICAgIGlmICh0aGlzLm5vZGVBKSB7XG4gICAgICB0aGlzLm5vZGVBLmlzRWRnZUhpZ2hsaWdodGVkKGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubm9kZUIpIHtcbiAgICAgIHRoaXMubm9kZUIuaXNFZGdlSGlnaGxpZ2h0ZWQoZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVkZ2VWaWV3TW9kZWw7XG4iLCJjb25zdCBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5jb25zdCBvY3RpY29ucyA9IHJlcXVpcmUoJ29jdGljb25zJyk7XG5jb25zdCBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xuY29uc3QgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG5jb25zdCBSZWZWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2dpdC1yZWYuanMnKTtcbmNvbnN0IEhvdmVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vaG92ZXItYWN0aW9ucycpO1xuXG5jb25zdCBSZWJhc2VWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuUmViYXNlVmlld01vZGVsO1xuY29uc3QgTWVyZ2VWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuTWVyZ2VWaWV3TW9kZWw7XG5jb25zdCBSZXNldFZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5SZXNldFZpZXdNb2RlbDtcbmNvbnN0IFB1c2hWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuUHVzaFZpZXdNb2RlbDtcbmNvbnN0IFNxdWFzaFZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5TcXVhc2hWaWV3TW9kZWw7XG5cbmNsYXNzIEFjdGlvbkJhc2Uge1xuICBjb25zdHJ1Y3RvcihncmFwaCwgdGV4dCwgc3R5bGUsIGljb24pIHtcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5zZXJ2ZXIgPSBncmFwaC5zZXJ2ZXI7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0ZWQgPSBrby5jb21wdXRlZCgoKSA9PiAhZ3JhcGguaG92ZXJHcmFwaEFjdGlvbigpIHx8IGdyYXBoLmhvdmVyR3JhcGhBY3Rpb24oKSA9PSB0aGlzKTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmljb24gPSBpY29uO1xuICAgIHRoaXMuY3NzQ2xhc3NlcyA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc0hpZ2hsaWdodGVkKCkgfHwgdGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5zdHlsZX0gZGltbWVkYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZG9QZXJmb3JtKCkge1xuICAgIGlmICh0aGlzLmlzUnVubmluZygpKSByZXR1cm47XG4gICAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xuICAgIHRoaXMuaXNSdW5uaW5nKHRydWUpO1xuICAgIHJldHVybiB0aGlzLnBlcmZvcm0oKVxuICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpXG4gICAgICAuZmluYWxseSgoKSA9PiB7IHRoaXMuaXNSdW5uaW5nKGZhbHNlKTsgfSk7XG4gIH1cblxuICBkcmFnRW50ZXIoKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbih0aGlzKTtcbiAgfVxuXG4gIGRyYWdMZWF2ZSgpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSgpKSByZXR1cm47XG4gICAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xuICB9XG5cbiAgbW91c2VvdmVyKCkge1xuICAgIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbih0aGlzKTtcbiAgfVxuXG4gIG1vdXNlb3V0KCkge1xuICAgIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbihudWxsKTtcbiAgfVxufVxuXG5cbmNsYXNzIE1vdmUgZXh0ZW5kcyBBY3Rpb25CYXNlIHtcbiAgY29uc3RydWN0b3IoZ3JhcGgsIG5vZGUpIHtcbiAgICBzdXBlcihncmFwaCwgJ01vdmUnLCAnbW92ZScsIG9jdGljb25zWydhcnJvdy1sZWZ0J10udG9TVkcoeyAnaGVpZ2h0JzogMTggfSkpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgICB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpICE9IHRoaXMubm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5tb3ZlVG8odGhpcy5ub2RlLnNoYTEpO1xuICB9XG59XG5cblxuY2xhc3MgUmVzZXQgZXh0ZW5kcyBBY3Rpb25CYXNlIHtcbiAgY29uc3RydWN0b3IgKGdyYXBoLCBub2RlKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdSZXNldCcsICdyZXNldCcsIG9jdGljb25zLnRyYXNoY2FuLnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pKTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICghKHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gICAgICBpZiAoY29udGV4dC5ub2RlKCkgIT0gdGhpcy5ub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCByZW1vdGVSZWYgPSBjb250ZXh0LmdldFJlbW90ZVJlZih0aGlzLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gICAgICByZXR1cm4gcmVtb3RlUmVmICYmIHJlbW90ZVJlZi5ub2RlKCkgJiZcbiAgICAgICAgY29udGV4dCAmJiBjb250ZXh0Lm5vZGUoKSAmJlxuICAgICAgICByZW1vdGVSZWYubm9kZSgpICE9IGNvbnRleHQubm9kZSgpICYmXG4gICAgICAgIHJlbW90ZVJlZi5ub2RlKCkuZGF0ZSA8IGNvbnRleHQubm9kZSgpLmRhdGU7XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVIb3ZlckdyYXBoaWMoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICBpZiAoIWNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgICBjb25zdCBub2RlcyA9IGNvbnRleHQubm9kZSgpLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKHJlbW90ZVJlZi5ub2RlKCkpLnNsaWNlKDAsIC0xKTtcbiAgICByZXR1cm4gbmV3IFJlc2V0Vmlld01vZGVsKG5vZGVzKTtcbiAgfVxuXG4gIHBlcmZvcm0oKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICBjb25zdCByZW1vdGVSZWYgPSBjb250ZXh0LmdldFJlbW90ZVJlZih0aGlzLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub2RpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmU/JywgZGV0YWlsczogJ1Jlc2V0dGluZyB0byByZWY6ICcgKyByZW1vdGVSZWYubmFtZSArICcgY2Fubm90IGJlIHVuZG9uZSB3aXRoIHVuZ2l0Lid9KVxuICAgICAgLnNob3coKVxuICAgICAgLmNsb3NlVGhlbigoZGlhZykgPT4ge1xuICAgICAgICBpZiAoIWRpYWcucmVzdWx0KCkpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcmVzZXQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgdG86IHJlbW90ZVJlZi5uYW1lLCBtb2RlOiAnaGFyZCcgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7IGNvbnRleHQubm9kZShyZW1vdGVSZWYubm9kZSgpKTsgfSk7XG4gICAgICB9KS5jbG9zZVByb21pc2U7XG4gIH1cbn1cblxuXG5jbGFzcyBSZWJhc2UgZXh0ZW5kcyBBY3Rpb25CYXNlIHtcbiAgY29uc3RydWN0b3IoZ3JhcGgsIG5vZGUpIHtcbiAgICBzdXBlcihncmFwaCwgJ1JlYmFzZScsICdyZWJhc2UnLCBvY3RpY29uc1sncmVwby1mb3JrZWQnXS50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KSk7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICAgICghdW5naXQuY29uZmlnLnNob3dSZWJhc2VBbmRNZXJnZU9ubHlPblJlZnMgfHwgdGhpcy5ub2RlLnJlZnMoKS5sZW5ndGggPiAwKSAmJlxuICAgICAgICB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpICYmXG4gICAgICAgIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgIT0gdGhpcy5ub2RlO1xuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlSG92ZXJHcmFwaGljKCkge1xuICAgIGxldCBvbnRvID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGlmICghb250bykgcmV0dXJuO1xuICAgIGlmIChvbnRvIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKSBvbnRvID0gb250by5ub2RlKCk7XG4gICAgY29uc3QgcGF0aCA9IG9udG8uZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IodGhpcy5ub2RlKTtcbiAgICByZXR1cm4gbmV3IFJlYmFzZVZpZXdNb2RlbCh0aGlzLm5vZGUsIHBhdGgpO1xuICB9XG5cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZWJhc2UnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgb250bzogdGhpcy5ub2RlLnNoYTEgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7IGlmIChlcnIuZXJyb3JDb2RlICE9ICdtZXJnZS1mYWlsZWQnKSB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZXJyKTsgfSk7XG4gIH1cbn1cblxuXG5jbGFzcyBNZXJnZSBleHRlbmRzIEFjdGlvbkJhc2Uge1xuICBjb25zdHJ1Y3RvcihncmFwaCwgbm9kZSkge1xuICAgIHN1cGVyKGdyYXBoLCAnTWVyZ2UnLCAnbWVyZ2UnLCBvY3RpY29uc1snZ2l0LW1lcmdlJ10udG9TVkcoeyAnaGVpZ2h0JzogMTggfSkpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKCF0aGlzLmdyYXBoLmNoZWNrZWRPdXRSZWYoKSB8fCAhdGhpcy5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICAgICF0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpICYmXG4gICAgICAgIHRoaXMuZ3JhcGguY2hlY2tlZE91dFJlZigpLm5vZGUoKSA9PSB0aGlzLm5vZGU7XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVIb3ZlckdyYXBoaWMoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkgbm9kZSA9IG5vZGUubm9kZSgpO1xuICAgIHJldHVybiBuZXcgTWVyZ2VWaWV3TW9kZWwodGhpcy5ncmFwaCwgdGhpcy5ub2RlLCBub2RlKTtcbiAgfVxuXG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvbWVyZ2UnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgd2l0aDogdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmxvY2FsUmVmTmFtZSB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHsgaWYgKGVyci5lcnJvckNvZGUgIT0gJ21lcmdlLWZhaWxlZCcpIHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlcnIpOyB9KTtcbiAgfVxufVxuXG5cbmNsYXNzIFB1c2ggZXh0ZW5kcyBBY3Rpb25CYXNlIHtcbiAgY29uc3RydWN0b3IoZ3JhcGgsIG5vZGUpIHtcbiAgICBzdXBlcihncmFwaCwgJ1B1c2gnLCAncHVzaCcsIG9jdGljb25zWydyZXBvLXB1c2gnXS50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KSk7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICAgIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgPT0gdGhpcy5ub2RlICYmXG4gICAgICAgIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jYW5CZVB1c2hlZCh0aGlzLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVIb3ZlckdyYXBoaWMoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICBpZiAoIWNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgICBpZiAoIXJlbW90ZVJlZikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5ldyBQdXNoVmlld01vZGVsKHJlbW90ZVJlZi5ub2RlKCksIGNvbnRleHQubm9kZSgpKTtcbiAgfVxuXG4gIHBlcmZvcm0oKSB7XG4gICAgY29uc3QgcmVmID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGNvbnN0IHJlbW90ZVJlZiA9IHJlZi5nZXRSZW1vdGVSZWYodGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuXG4gICAgaWYgKHJlbW90ZVJlZikge1xuICAgICAgcmV0dXJuIHJlbW90ZVJlZi5tb3ZlVG8ocmVmLm5vZGUoKS5zaGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlZi5jcmVhdGVSZW1vdGVSZWYoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5ncmFwaC5IRUFEKCkubmFtZSA9PSByZWYubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5ncmFoLkhFQURyZWYoKS5ub2RlKHJlZi5ub2RlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuZmluYWxseSgoKSA9PiBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LWZldGNoLXRhZ3MnIH0pKTtcbiAgICB9XG4gIH1cbn1cblxuXG5jbGFzcyBDaGVja291dCBleHRlbmRzIEFjdGlvbkJhc2Uge1xuICBjb25zdHJ1Y3RvcihncmFwaCwgbm9kZSkge1xuICAgIHN1cGVyKGdyYXBoLCAnQ2hlY2tvdXQnLCAnY2hlY2tvdXQnLCBvY3RpY29uc1snZGVza3RvcC1kb3dubG9hZCddLnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pKTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpXG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpID09IHRoaXMubm9kZSAmJlxuICAgICAgICAgICF0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpO1xuICAgICAgcmV0dXJuIHVuZ2l0LmNvbmZpZy5hbGxvd0NoZWNrb3V0Tm9kZXMgJiZcbiAgICAgICAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHRoaXMubm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jaGVja291dCgpO1xuICB9XG59XG5cblxuY2xhc3MgRGVsZXRlIGV4dGVuZHMgQWN0aW9uQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoLCBub2RlKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdEZWxldGUnLCAnZGVsZXRlJywgb2N0aWNvbnMueC50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KSk7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICAgIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgPT0gdGhpcy5ub2RlICYmXG4gICAgICAgICF0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgcGVyZm9ybSgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGxldCBkZXRhaWxzID0gYFwiJHtjb250ZXh0LnJlZk5hbWV9XCJgO1xuICAgIGlmIChjb250ZXh0LmlzUmVtb3RlQnJhbmNoKSB7XG4gICAgICBkZXRhaWxzID0gYDxjb2RlIF9zdHlsZT1cImZvbnQtc2l6ZTogMTAwJVwiPlJFTU9URTwvY29kZT4gJHtkZXRhaWxzfWA7XG4gICAgfVxuICAgIGRldGFpbHMgPSBgRGVsZXRpbmcgJHtkZXRhaWxzfSBicmFuY2ggb3IgdGFnIGNhbm5vdCBiZSB1bmRvbmUgd2l0aCB1bmdpdC5gO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub2RpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmU/JywgZGV0YWlsczogZGV0YWlscyB9KVxuICAgICAgLnNob3coKVxuICAgICAgLmNsb3NlVGhlbigoZGlhZykgPT4ge1xuICAgICAgICBpZiAoZGlhZy5yZXN1bHQoKSkgcmV0dXJuIGNvbnRleHQucmVtb3ZlKCk7XG4gICAgICB9KS5jbG9zZVByb21pc2U7XG4gIH1cbn1cblxuXG5jbGFzcyBDaGVycnlQaWNrIGV4dGVuZHMgQWN0aW9uQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoLCBub2RlKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdDaGVycnkgcGljaycsICdjaGVycnktcGljaycsIG9jdGljb25zWydjaXJjdWl0LWJvYXJkJ10udG9TVkcoeyAnaGVpZ2h0JzogMTggfSkpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICAgIHJldHVybiBjb250ZXh0ID09PSB0aGlzLm5vZGUgJiYgdGhpcy5ncmFwaC5IRUFEKCkgJiYgY29udGV4dC5zaGExICE9PSB0aGlzLmdyYXBoLkhFQUQoKS5zaGExO1xuICAgIH0pO1xuICB9XG5cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9jaGVycnlwaWNrJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIG5hbWU6IHRoaXMubm9kZS5zaGExIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4geyBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykgdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7IH0pO1xuICB9XG59XG5cblxuY2xhc3MgVW5jb21taXQgZXh0ZW5kcyBBY3Rpb25CYXNlIHtcbiAgY29uc3RydWN0b3IoZ3JhcGgsIG5vZGUpIHtcbiAgICBzdXBlcihncmFwaCwgJ1VuY29tbWl0JywgJ3VuY29tbWl0Jywgb2N0aWNvbnMuemFwLnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pKTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gdGhpcy5ub2RlICYmXG4gICAgICAgIHRoaXMuZ3JhcGguSEVBRCgpID09IHRoaXMubm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcmVzZXQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgdG86ICdIRUFEXicsIG1vZGU6ICdtaXhlZCcgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSB0aGlzLm5vZGUuYmVsb3dOb2RlO1xuICAgICAgICB3aGlsZSAodGFyZ2V0Tm9kZSAmJiAhdGFyZ2V0Tm9kZS5hbmNlc3Rvck9mSEVBRCgpKSB7XG4gICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRhcmdldE5vZGUuYmVsb3dOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGguSEVBRHJlZigpLm5vZGUodGFyZ2V0Tm9kZSA/IHRhcmdldE5vZGUgOiBudWxsKTtcbiAgICAgICAgdGhpcy5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSh0YXJnZXROb2RlID8gdGFyZ2V0Tm9kZSA6IG51bGwpO1xuICAgICAgfSk7XG4gIH1cbn1cblxuXG5jbGFzcyBSZXZlcnQgZXh0ZW5kcyBBY3Rpb25CYXNlIHtcbiAgY29uc3RydWN0b3IoZ3JhcGgsIG5vZGUpIHtcbiAgICBzdXBlcihncmFwaCwgJ1JldmVydCcsICdyZXZlcnQnLCBvY3RpY29ucy5oaXN0b3J5LnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pKTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gdGhpcy5ub2RlO1xuICAgIH0pO1xuICB9XG5cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXZlcnQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgY29tbWl0OiB0aGlzLm5vZGUuc2hhMSB9KTtcbiAgfVxufVxuXG5cbmNsYXNzIFNxdWFzaCBleHRlbmRzIEFjdGlvbkJhc2Uge1xuICBjb25zdHJ1Y3RvcihncmFwaCwgbm9kZSkge1xuICAgIHN1cGVyKGdyYXBoLCAnU3F1YXNoJywgJ3NxdWFzaCcsIG9jdGljb25zLmZvbGQudG9TVkcoeyAnaGVpZ2h0JzogMTggfSkpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgICB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpICYmXG4gICAgICAgIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgIT0gdGhpcy5ub2RlO1xuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlSG92ZXJHcmFwaGljKCkge1xuICAgIGxldCBvbnRvID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGlmICghb250bykgcmV0dXJuO1xuICAgIGlmIChvbnRvIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKSBvbnRvID0gb250by5ub2RlKCk7XG5cbiAgICByZXR1cm4gbmV3IFNxdWFzaFZpZXdNb2RlbCh0aGlzLm5vZGUsIG9udG8pO1xuICB9XG5cbiAgcGVyZm9ybSgpIHtcbiAgICBsZXQgb250byA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICBpZiAoIW9udG8pIHJldHVybjtcbiAgICBpZiAob250byBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkgb250byA9IG9udG8ubm9kZSgpO1xuICAgIC8vIHJlbW92ZSBsYXN0IGVsZW1lbnQgYXMgaXQgd291bGQgYmUgYSBjb21tb24gYW5jZXN0b3IuXG4gICAgY29uc3QgcGF0aCA9IHRoaXMubm9kZS5nZXRQYXRoVG9Db21tb25BbmNlc3RvcihvbnRvKS5zbGljZSgwLCAtMSk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBzcXVhc2hpbmcgYnJhbmNoZWQgb3V0IGxpbmVhZ2VcbiAgICAgIC8vIGMgaXMgY2hlY2tvdXQgd2l0aCBzcXVhc2ggdGFyZ2V0IG9mIGUsIHJlc3VsdHMgaW4gc3RhZ2luZyBjaGFuZ2VzXG4gICAgICAvLyBmcm9tIGQgYW5kIGUgb24gdG9wIG9mIGNcbiAgICAgIC8vXG4gICAgICAvLyBhIC0gYiAtIChjKSAgICAgICAgYSAtIGIgLSAoYykgLSBbZGVdXG4gICAgICAvLyAgXFwgICAgICAgICAgIC0+ICAgICBcXFxuICAgICAgLy8gICBkICAtIDxlPiAgICAgICAgICAgZCAtIDxlPlxuICAgICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvc3F1YXNoJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHRhcmdldDogdGhpcy5ub2RlLnNoYTEgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNxdWFzaGluZyBiYWNrd2FyZCBmcm9tIHNhbWUgbGluZWFnZVxuICAgICAgLy8gYyBpcyBjaGVja291dCB3aXRoIHNxdWFzaCB0YXJnZXQgb2YgYSwgcmVzdWx0cyBpbiBjdXJyZW50IHJlZiBtb3ZlZFxuICAgICAgLy8gdG8gYSBhbmQgc3RhZ2luZyBjaGFuZ2VzIHdpdGhpbiBiIGFuZCBjIG9uIHRvcCBvZiBhXG4gICAgICAvL1xuICAgICAgLy8gPGE+IC0gYiAtIChjKSAgICAgICAoYSkgLSBiIC0gY1xuICAgICAgLy8gICAgICAgICAgICAgICAgLT4gICAgIFxcXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIFtiY11cbiAgICAgIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubW92ZVRvKHRoaXMubm9kZS5zaGExLCB0cnVlKVxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3NxdWFzaCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCB0YXJnZXQ6IG9udG8uc2hhMSB9KSk7XG4gICAgfVxuICB9XG59XG5cblxuY29uc3QgR3JhcGhBY3Rpb25zID0ge1xuICBNb3ZlOiBNb3ZlLFxuICBSZWJhc2U6IFJlYmFzZSxcbiAgTWVyZ2U6IE1lcmdlLFxuICBQdXNoOiBQdXNoLFxuICBSZXNldDogUmVzZXQsXG4gIENoZWNrb3V0OiBDaGVja291dCxcbiAgRGVsZXRlOiBEZWxldGUsXG4gIENoZXJyeVBpY2s6IENoZXJyeVBpY2ssXG4gIFVuY29tbWl0OiBVbmNvbW1pdCxcbiAgUmV2ZXJ0OiBSZXZlcnQsXG4gIFNxdWFzaDogU3F1YXNoLFxufTtcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhBY3Rpb25zO1xuIiwiY29uc3QgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuY29uc3Qga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuY29uc3QgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbmNvbnN0IHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xuY29uc3QgQW5pbWF0ZWFibGUgPSByZXF1aXJlKCcuL2FuaW1hdGVhYmxlJyk7XG5jb25zdCBHcmFwaEFjdGlvbnMgPSByZXF1aXJlKCcuL2dpdC1ncmFwaC1hY3Rpb25zJyk7XG5cbmNvbnN0IG1heEJyYW5jaGVzVG9EaXNwbGF5ID0gcGFyc2VJbnQodW5naXQuY29uZmlnLm51bVJlZnNUb1Nob3cgLyA1ICogMyk7ICAvLyAzLzUgb2YgcmVmcyB0byBzaG93IHRvIGJyYW5jaGVzXG5jb25zdCBtYXhUYWdzVG9EaXNwbGF5ID0gdW5naXQuY29uZmlnLm51bVJlZnNUb1Nob3cgLSBtYXhCcmFuY2hlc1RvRGlzcGxheTsgLy8gMi81IG9mIHJlZnMgdG8gc2hvdyB0byB0YWdzXG5cbmNsYXNzIEdpdE5vZGVWaWV3TW9kZWwgZXh0ZW5kcyBBbmltYXRlYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoLCBzaGExKSB7XG4gICAgc3VwZXIoZ3JhcGgpO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLnNoYTEgPSBzaGExO1xuICAgIHRoaXMuaXNJbml0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRpdGxlID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMucGFyZW50cyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICAgIHRoaXMuY29tbWl0VGltZSA9IHVuZGVmaW5lZDsgLy8gY29tbWl0IHRpbWUgaW4gc3RyaW5nXG4gICAgdGhpcy5kYXRlID0gdW5kZWZpbmVkOyAgICAgICAvLyBjb21taXQgdGltZSBpbiBudW1lcmljIGZvcm1hdCBmb3Igc29ydFxuICAgIHRoaXMuY29sb3IgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5pZGVvbG9naWNhbEJyYW5jaCA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLnJlbW90ZVRhZ3MgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gICAgdGhpcy5zaWduYXR1cmVEYXRlID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuc2lnbmF0dXJlTWFkZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLnBncFZlcmlmaWVkU3RyaW5nID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlTWFkZSgpKSB7XG4gICAgICAgIHJldHVybiBgUEdQIGJ5OiAke3RoaXMuc2lnbmF0dXJlTWFkZSgpfSBhdCAke3RoaXMuc2lnbmF0dXJlRGF0ZSgpfWA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZnMgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICBjb25zdCBycyA9IHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3MoKS5jb25jYXQodGhpcy5yZW1vdGVUYWdzKCkpO1xuICAgICAgcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYi5jdXJyZW50KCkpIHJldHVybiAxO1xuICAgICAgICBpZiAoYS5jdXJyZW50KCkpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEuaXNMb2NhbCAmJiAhYi5pc0xvY2FsKSByZXR1cm4gLTE7XG4gICAgICAgIGlmICghYS5pc0xvY2FsICYmIGIuaXNMb2NhbCkgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiBhLnJlZk5hbWUgPCBiLnJlZk5hbWUgPyAtMSA6IDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBycztcbiAgICB9KTtcbiAgICAvLyBUaGVzZSBhcmUgc3BsaXQgdXAgbGlrZSB0aGlzIGJlY2F1c2UgYnJhbmNoZXMgYW5kIGxvY2FsIHRhZ3MgY2FuIGJlIGZvdW5kIGluIHRoZSBnaXQgbG9nLFxuICAgIC8vIHdoZXJlYXMgcmVtb3RlIHRhZ3MgbmVlZHMgdG8gYmUgZmV0Y2hlZCB3aXRoIGFub3RoZXIgY29tbWFuZCAod2hpY2ggaXMgbXVjaCBzbG93ZXIpXG4gICAgdGhpcy5icmFuY2hlcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICAgIHRoaXMuYnJhbmNoZXNUb0Rpc3BsYXkgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB0aGlzLnRhZ3MgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB0aGlzLnRhZ3NUb0Rpc3BsYXkgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB0aGlzLnJlZnMuc3Vic2NyaWJlKChuZXdWYWx1ZSkgPT4ge1xuICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnJhbmNoZXMobmV3VmFsdWUuZmlsdGVyKChyKSA9PiByLmlzQnJhbmNoKSk7XG4gICAgICAgIHRoaXMudGFncyhuZXdWYWx1ZS5maWx0ZXIoKHIpID0+IHIuaXNUYWcpKTtcbiAgICAgICAgdGhpcy50YWdzVG9EaXNwbGF5KHRoaXMudGFncy5zbGljZSgwLCBtYXhUYWdzVG9EaXNwbGF5KSk7XG4gICAgICAgIHRoaXMuYnJhbmNoZXNUb0Rpc3BsYXkodGhpcy5icmFuY2hlcy5zbGljZSgwLCB1bmdpdC5jb25maWcubnVtUmVmc1RvU2hvdyAtIHRoaXMudGFnc1RvRGlzcGxheSgpLmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5icmFuY2hlcy5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy50YWdzLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLmJyYW5jaGVzVG9EaXNwbGF5LnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLnRhZ3NUb0Rpc3BsYXkucmVtb3ZlQWxsKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hbmNlc3Rvck9mSEVBRCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMubm9kZUlzTW91c2Vob3ZlciA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuY29tbWl0Q29udGFpbmVyVmlzaWJsZSA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMuYW5jZXN0b3JPZkhFQUQoKSB8fCB0aGlzLm5vZGVJc01vdXNlaG92ZXIoKSB8fCB0aGlzLnNlbGVjdGVkKCkpO1xuICAgIHRoaXMuaXNFZGdlSGlnaGxpZ2h0ZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICAvLyBmb3Igc21hbGwgZW1wdHkgYmxhY2sgY2lyY2xlIHRvIGhpZ2hsaWdodCBhIG5vZGVcbiAgICB0aGlzLmlzTm9kZUFjY2VudGVkID0ga28uY29tcHV0ZWQoKCkgPT4gdGhpcy5zZWxlY3RlZCgpIHx8IHRoaXMuaXNFZGdlSGlnaGxpZ2h0ZWQoKSk7XG4gICAgLy8gdG8gc2hvdyBjaGFuZ2VkIGZpbGVzIGFuZCBkaWZmIGJveGVzIG9uIHRoZSBsZWZ0IG9mIG5vZGVcbiAgICB0aGlzLmhpZ2hsaWdodGVkID0ga28uY29tcHV0ZWQoKCkgPT4gdGhpcy5ub2RlSXNNb3VzZWhvdmVyKCkgfHwgdGhpcy5zZWxlY3RlZCgpKTtcbiAgICB0aGlzLnNlbGVjdGVkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdncmFwaC1yZW5kZXInIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2hvd05ld1JlZkFjdGlvbiA9IGtvLmNvbXB1dGVkKCgpID0+ICFncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpKTtcbiAgICB0aGlzLm5ld0JyYW5jaE5hbWUgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5uZXdCcmFuY2hOYW1lSGFzRm9jdXMgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuICAgIHRoaXMuYnJhbmNoaW5nRm9ybVZpc2libGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmNhbkNyZWF0ZVJlZiA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMubmV3QnJhbmNoTmFtZSgpICYmIHRoaXMubmV3QnJhbmNoTmFtZSgpLnRyaW0oKSAmJiAhdGhpcy5uZXdCcmFuY2hOYW1lKCkuaW5jbHVkZXMoJyAnKSk7XG4gICAgdGhpcy5icmFuY2hPcmRlciA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLmFib3ZlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlbG93Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlZlNlYXJjaEZvcm1WaXNpYmxlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5jb21taXRDb21wb25lbnQgPSBjb21wb25lbnRzLmNyZWF0ZSgnY29tbWl0JywgdGhpcyk7XG4gICAgdGhpcy5yID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuY3ggPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5jeSA9IGtvLm9ic2VydmFibGUoKTtcblxuICAgIHRoaXMuZHJvcGFyZWFHcmFwaEFjdGlvbnMgPSBbXG4gICAgICBuZXcgR3JhcGhBY3Rpb25zLk1vdmUodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgICBuZXcgR3JhcGhBY3Rpb25zLlJlYmFzZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICAgIG5ldyBHcmFwaEFjdGlvbnMuTWVyZ2UodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgICBuZXcgR3JhcGhBY3Rpb25zLlB1c2godGhpcy5ncmFwaCwgdGhpcyksXG4gICAgICBuZXcgR3JhcGhBY3Rpb25zLlJlc2V0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgICAgbmV3IEdyYXBoQWN0aW9ucy5DaGVja291dCh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICAgIG5ldyBHcmFwaEFjdGlvbnMuRGVsZXRlKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgICAgbmV3IEdyYXBoQWN0aW9ucy5DaGVycnlQaWNrKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgICAgbmV3IEdyYXBoQWN0aW9ucy5VbmNvbW1pdCh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICAgIG5ldyBHcmFwaEFjdGlvbnMuUmV2ZXJ0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgICAgbmV3IEdyYXBoQWN0aW9ucy5TcXVhc2godGhpcy5ncmFwaCwgdGhpcylcbiAgICBdO1xuICB9XG5cbiAgZ2V0R3JhcGhBdHRyKCkge1xuICAgIHJldHVybiBbdGhpcy5jeCgpLCB0aGlzLmN5KCldO1xuICB9XG5cbiAgc2V0R3JhcGhBdHRyKHZhbCkge1xuICAgIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgneCcsIHZhbFswXSAtIDMwKTtcbiAgICB0aGlzLmVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3knLCB2YWxbMV0gLSAzMCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5yZWZTZWFyY2hGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGVkKSByZXR1cm47XG4gICAgaWYgKHRoaXMuYW5jZXN0b3JPZkhFQUQoKSkge1xuICAgICAgdGhpcy5yKDMwKTtcbiAgICAgIHRoaXMuY3goNjEwKTtcblxuICAgICAgaWYgKCF0aGlzLmFib3ZlTm9kZSkge1xuICAgICAgICB0aGlzLmN5KDEyMCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYWJvdmVOb2RlLmFuY2VzdG9yT2ZIRUFEKCkpIHtcbiAgICAgICAgdGhpcy5jeSh0aGlzLmFib3ZlTm9kZS5jeSgpICsgMTIwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUuY3koKSArIDYwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yKDE1KTtcbiAgICAgIHRoaXMuY3goNjEwICsgKDkwICogdGhpcy5icmFuY2hPcmRlcigpKSk7XG4gICAgICB0aGlzLmN5KHRoaXMuYWJvdmVOb2RlID8gdGhpcy5hYm92ZU5vZGUuY3koKSArIDYwIDogMTIwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hYm92ZU5vZGUgJiYgdGhpcy5hYm92ZU5vZGUuc2VsZWN0ZWQoKSkge1xuICAgICAgdGhpcy5jeSh0aGlzLmFib3ZlTm9kZS5jeSgpICsgdGhpcy5hYm92ZU5vZGUuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5vZmZzZXRIZWlnaHQgKyAzMCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2xvcih0aGlzLmlkZW9sb2dpY2FsQnJhbmNoKCkgPyB0aGlzLmlkZW9sb2dpY2FsQnJhbmNoKCkuY29sb3IgOiAnIzY2NicpO1xuICAgIHRoaXMuYW5pbWF0ZSgpO1xuICB9XG5cbiAgc2V0RGF0YShsb2dFbnRyeSkge1xuICAgIHRoaXMudGl0bGUobG9nRW50cnkubWVzc2FnZS5zcGxpdCgnXFxuJylbMF0pO1xuICAgIHRoaXMucGFyZW50cyhsb2dFbnRyeS5wYXJlbnRzIHx8IFtdKTtcbiAgICB0aGlzLmNvbW1pdFRpbWUgPSBsb2dFbnRyeS5jb21taXREYXRlO1xuICAgIHRoaXMuZGF0ZSA9IERhdGUucGFyc2UodGhpcy5jb21taXRUaW1lKTtcbiAgICB0aGlzLmNvbW1pdENvbXBvbmVudC5zZXREYXRhKGxvZ0VudHJ5KTtcbiAgICB0aGlzLnNpZ25hdHVyZU1hZGUobG9nRW50cnkuc2lnbmF0dXJlTWFkZSk7XG4gICAgdGhpcy5zaWduYXR1cmVEYXRlKGxvZ0VudHJ5LnNpZ25hdHVyZURhdGUpO1xuXG4gICAgKGxvZ0VudHJ5LnJlZnMgfHwgW10pLmZvckVhY2gocmVmID0+IHtcbiAgICAgIHRoaXMuZ3JhcGguZ2V0UmVmKHJlZikubm9kZSh0aGlzKTtcbiAgICB9KTtcbiAgICB0aGlzLmlzSW5pdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHNob3dCcmFuY2hpbmdGb3JtKCkge1xuICAgIHRoaXMuYnJhbmNoaW5nRm9ybVZpc2libGUodHJ1ZSk7XG4gICAgdGhpcy5uZXdCcmFuY2hOYW1lSGFzRm9jdXModHJ1ZSk7XG4gIH1cblxuICBzaG93UmVmU2VhcmNoRm9ybShvYmosIGV2ZW50KSB7XG4gICAgdGhpcy5yZWZTZWFyY2hGb3JtVmlzaWJsZSh0cnVlKTtcblxuICAgIGNvbnN0IHRleHRCb3ggPSBldmVudC5jdXJyZW50VGFyZ2V0Lm5leHRFbGVtZW50U2libGluZy5maXJzdEVsZW1lbnRDaGlsZDsgLy8gdGhpcyBtYXkgbm90IGJlIHRoZSBiZXN0IGlkZWEuLi5cbiAgICAkKHRleHRCb3gpLmF1dG9jb21wbGV0ZSh7XG4gICAgICBzb3VyY2U6IHRoaXMucmVmcygpLmZpbHRlcihyZWYgPT4gIXJlZi5pc0hFQUQpLFxuICAgICAgbWluTGVuZ3RoOiAwLFxuICAgICAgc2VsZWN0OiAoZXZlbnQsIHVpKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHVpLml0ZW07XG4gICAgICAgIGNvbnN0IHJheSA9IHJlZi5pc1RhZyA/IHRoaXMudGFnc1RvRGlzcGxheSA6IHRoaXMuYnJhbmNoZXNUb0Rpc3BsYXk7XG5cbiAgICAgICAgLy8gaWYgcmVmIGlzIGluIGRpc3BsYXksIHJlbW92ZSBpdCwgZWxzZSByZW1vdmUgbGFzdCBpbiBhcnJheS5cbiAgICAgICAgcmF5LnNwbGljZShyYXkuaW5kZXhPZihyZWYpLCAxKTtcbiAgICAgICAgcmF5LnVuc2hpZnQocmVmKTtcbiAgICAgICAgdGhpcy5yZWZTZWFyY2hGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgbm9SZXN1bHRzOiAnJyxcbiAgICAgICAgcmVzdWx0czogKCkgPT4ge31cbiAgICAgIH1cbiAgICB9KS5mb2N1cygoKSA9PiB7XG4gICAgICAkKHRoaXMpLmF1dG9jb21wbGV0ZSgnc2VhcmNoJywgJCh0aGlzKS52YWwoKSk7XG4gICAgfSkuZGF0YSgndWktYXV0b2NvbXBsZXRlJykuX3JlbmRlckl0ZW0gPSAodWwsIGl0ZW0pID0+ICQoJzxsaT48L2xpPicpXG4gICAgICAuYXBwZW5kKGA8YT4ke2l0ZW0uZG9tfTwvYT5gKVxuICAgICAgLmFwcGVuZFRvKHVsKTtcbiAgICAkKHRleHRCb3gpLmF1dG9jb21wbGV0ZSgnc2VhcmNoJywgJycpO1xuICB9XG5cbiAgY3JlYXRlQnJhbmNoKCkge1xuICAgIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICAgIHRoaXMuZ3JhcGguc2VydmVyLnBvc3RQcm9taXNlKCcvYnJhbmNoZXMnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgbmFtZTogdGhpcy5uZXdCcmFuY2hOYW1lKCksIHNoYTE6IHRoaXMuc2hhMSB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmdyYXBoLmdldFJlZihgcmVmcy9oZWFkcy8ke3RoaXMubmV3QnJhbmNoTmFtZSgpfWApLm5vZGUodGhpcyk7XG4gICAgICAgIGlmICh1bmdpdC5jb25maWcuYXV0b0NoZWNrb3V0T25CcmFuY2hDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaC5zZXJ2ZXIucG9zdFByb21pc2UoJy9jaGVja291dCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLm5ld0JyYW5jaE5hbWUoKSB9KTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGUpID0+IHRoaXMuZ3JhcGguc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMubmV3QnJhbmNoTmFtZSgnJyk7XG4gICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2JyYW5jaC11cGRhdGVkJyB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlVGFnKCkge1xuICAgIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICAgIHRoaXMuZ3JhcGguc2VydmVyLnBvc3RQcm9taXNlKCcvdGFncycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLm5ld0JyYW5jaE5hbWUoKSwgc2hhMTogdGhpcy5zaGExIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmdyYXBoLmdldFJlZihgcmVmcy90YWdzLyR7dGhpcy5uZXdCcmFuY2hOYW1lKCl9YCkubm9kZSh0aGlzKSApXG4gICAgICAuY2F0Y2goKGUpID0+IHRoaXMuZ3JhcGguc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMubmV3QnJhbmNoTmFtZSgnJyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHRvZ2dsZVNlbGVjdGVkKCkge1xuICAgIGNvbnN0IGJlZm9yZVRoaXNDUiA9IHRoaXMuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgYmVmb3JlQmVsb3dDUiA9IG51bGw7XG4gICAgaWYgKHRoaXMuYmVsb3dOb2RlKSB7XG4gICAgICBiZWZvcmVCZWxvd0NSID0gdGhpcy5iZWxvd05vZGUuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBsZXQgcHJldlNlbGVjdGVkICA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICBpZiAoIShwcmV2U2VsZWN0ZWQgaW5zdGFuY2VvZiBHaXROb2RlVmlld01vZGVsKSkgcHJldlNlbGVjdGVkID0gbnVsbDtcbiAgICBjb25zdCBwcmV2U2VsZWN0ZWRDUiA9IHByZXZTZWxlY3RlZCA/IHByZXZTZWxlY3RlZC5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcbiAgICB0aGlzLnNlbGVjdGVkKCF0aGlzLnNlbGVjdGVkKCkpO1xuXG4gICAgLy8gSWYgd2UgYXJlIGRlc2VsZWN0aW5nXG4gICAgaWYgKCF0aGlzLnNlbGVjdGVkKCkpIHtcbiAgICAgIGlmIChiZWZvcmVUaGlzQ1IudG9wIDwgMCAmJiBiZWZvcmVCZWxvd0NSKSB7XG4gICAgICAgIGNvbnN0IGFmdGVyQmVsb3dDUiA9IHRoaXMuYmVsb3dOb2RlLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgc2hvd2luZywgdHJ5IHRvIGtlZXAgaXQgaW4gdGhlIHNjcmVlbiAobm8ganVtcGluZylcbiAgICAgICAgaWYgKGJlZm9yZUJlbG93Q1IudG9wIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIGFmdGVyQmVsb3dDUi50b3AgLSBiZWZvcmVCZWxvd0NSLnRvcCk7XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHRyeSB0byBicmluZyB0aGVtIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBhZnRlckJlbG93Q1IudG9wIC0gd2luZG93LmlubmVySGVpZ2h0IC8gMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAvLyBJZiB3ZSBhcmUgc2VsZWN0aW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFmdGVyVGhpc0NSID0gdGhpcy5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKChwcmV2U2VsZWN0ZWRDUiAmJiAocHJldlNlbGVjdGVkQ1IudG9wIDwgMCB8fCBwcmV2U2VsZWN0ZWRDUi50b3AgPiB3aW5kb3cuaW5uZXJIZWlnaHQpKSAmJlxuICAgICAgICBhZnRlclRoaXNDUi50b3AgIT0gYmVmb3JlVGhpc0NSLnRvcCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgLShiZWZvcmVUaGlzQ1IudG9wIC0gYWZ0ZXJUaGlzQ1IudG9wKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGaXgnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmVtb3ZlUmVmKHJlZikge1xuICAgIGlmIChyZWYuaXNSZW1vdGVUYWcpIHtcbiAgICAgIHRoaXMucmVtb3RlVGFncy5yZW1vdmUocmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5icmFuY2hlc0FuZExvY2FsVGFncy5yZW1vdmUocmVmKTtcbiAgICB9XG4gIH1cblxuICBwdXNoUmVmKHJlZikge1xuICAgIGlmIChyZWYuaXNSZW1vdGVUYWcgJiYgIXRoaXMucmVtb3RlVGFncygpLmluY2x1ZGVzKHJlZikpIHtcbiAgICAgIHRoaXMucmVtb3RlVGFncy5wdXNoKHJlZik7XG4gICAgfSBlbHNlIGlmKCF0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzKCkuaW5jbHVkZXMocmVmKSkge1xuICAgICAgdGhpcy5icmFuY2hlc0FuZExvY2FsVGFncy5wdXNoKHJlZik7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQW5pbWF0aW9uRnJhbWUoZGVsdGFUKSB7XG4gICAgdGhpcy5jb21taXRDb21wb25lbnQudXBkYXRlQW5pbWF0aW9uRnJhbWUoZGVsdGFUKTtcbiAgfVxuXG4gIGdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKG5vZGUpIHtcbiAgICBjb25zdCBwYXRoID0gW107XG4gICAgbGV0IHRoaXNOb2RlID0gdGhpcztcbiAgICB3aGlsZSAodGhpc05vZGUgJiYgIW5vZGUuaXNBbmNlc3Rvcih0aGlzTm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaCh0aGlzTm9kZSk7XG4gICAgICB0aGlzTm9kZSA9IHRoaXMuZ3JhcGgubm9kZXNCeUlkW3RoaXNOb2RlLnBhcmVudHMoKVswXV07XG4gICAgfVxuICAgIGlmICh0aGlzTm9kZSkgcGF0aC5wdXNoKHRoaXNOb2RlKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIGlzQW5jZXN0b3Iobm9kZSkge1xuICAgIGlmIChub2RlID09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3QgdiBpbiB0aGlzLnBhcmVudHMoKSkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuZ3JhcGgubm9kZXNCeUlkW3RoaXMucGFyZW50cygpW3ZdXTtcbiAgICAgIGlmIChuICYmIG4uaXNBbmNlc3Rvcihub2RlKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldFJpZ2h0VG9MZWZ0U3RyaWtlKCkge1xuICAgIHJldHVybiBgTSAke3RoaXMuY3goKSAtIDMwfSAke3RoaXMuY3koKSAtIDMwfSBMICR7dGhpcy5jeCgpICsgMzB9ICR7dGhpcy5jeSgpICsgMzB9YDtcbiAgfVxuXG4gIGdldExlZnRUb1JpZ2h0U3RyaWtlKCkge1xuICAgIHJldHVybiBgTSAke3RoaXMuY3goKSArIDMwfSAke3RoaXMuY3koKSAtIDMwfSBMICR7dGhpcy5jeCgpIC0gMzB9ICR7dGhpcy5jeSgpICsgMzB9YDtcbiAgfVxuXG4gIG5vZGVNb3VzZW92ZXIoKSB7XG4gICAgdGhpcy5ub2RlSXNNb3VzZWhvdmVyKHRydWUpO1xuICB9XG5cbiAgbm9kZU1vdXNlb3V0KCkge1xuICAgIHRoaXMubm9kZUlzTW91c2Vob3ZlcihmYWxzZSk7XG4gIH1cblxuICBpc1ZpZXdhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdyYXBoLm5vZGVzKCkuaW5jbHVkZXModGhpcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHaXROb2RlVmlld01vZGVsO1xuIiwiY29uc3Qga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuY29uc3QgbWQ1ID0gcmVxdWlyZSgnYmx1ZWltcC1tZDUnKTtcbmNvbnN0IHByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuY29uc3Qgb2N0aWNvbnMgPSByZXF1aXJlKCdvY3RpY29ucycpO1xuY29uc3QgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG5jb25zdCBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xuY29uc3QgU2VsZWN0YWJsZSA9IHJlcXVpcmUoJy4vc2VsZWN0YWJsZScpO1xuXG5jbGFzcyBSZWZWaWV3TW9kZWwgZXh0ZW5kcyBTZWxlY3RhYmxlIHtcbiAgY29uc3RydWN0b3IoZnVsbFJlZk5hbWUsIGdyYXBoKSB7XG4gICAgc3VwZXIoZ3JhcGgpO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLm5hbWUgPSBmdWxsUmVmTmFtZTtcbiAgICB0aGlzLm5vZGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWU7IC8vIG9yaWdpbi9tYXN0ZXIgb3IgbWFzdGVyXG4gICAgdGhpcy5yZWZOYW1lID0gdGhpcy5uYW1lOyAvLyBtYXN0ZXJcbiAgICB0aGlzLmlzUmVtb3RlVGFnID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlbW90ZS10YWc6ICcpID09IDA7XG4gICAgdGhpcy5pc0xvY2FsVGFnID0gdGhpcy5uYW1lLmluZGV4T2YoJ3RhZzogJykgPT0gMDtcbiAgICB0aGlzLmlzVGFnID0gdGhpcy5pc0xvY2FsVGFnIHx8IHRoaXMuaXNSZW1vdGVUYWc7XG4gICAgY29uc3QgaXNSZW1vdGVCcmFuY2hPckhFQUQgPSB0aGlzLm5hbWUuaW5kZXhPZigncmVmcy9yZW1vdGVzLycpID09IDA7XG4gICAgdGhpcy5pc0xvY2FsSEVBRCA9IHRoaXMubmFtZSA9PSAnSEVBRCc7XG4gICAgdGhpcy5pc1JlbW90ZUhFQUQgPSB0aGlzLm5hbWUuaW5jbHVkZXMoJy9IRUFEJyk7XG4gICAgdGhpcy5pc0xvY2FsQnJhbmNoID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlZnMvaGVhZHMvJykgPT0gMDtcbiAgICB0aGlzLmlzUmVtb3RlQnJhbmNoID0gaXNSZW1vdGVCcmFuY2hPckhFQUQgJiYgIXRoaXMuaXNSZW1vdGVIRUFEO1xuICAgIHRoaXMuaXNTdGFzaCA9IHRoaXMubmFtZS5pbmRleE9mKCdyZWZzL3N0YXNoJykgPT0gMDtcbiAgICB0aGlzLmlzSEVBRCA9IHRoaXMuaXNMb2NhbEhFQUQgfHwgdGhpcy5pc1JlbW90ZUhFQUQ7XG4gICAgdGhpcy5pc0JyYW5jaCA9IHRoaXMuaXNMb2NhbEJyYW5jaCB8fCB0aGlzLmlzUmVtb3RlQnJhbmNoO1xuICAgIHRoaXMuaXNSZW1vdGUgPSBpc1JlbW90ZUJyYW5jaE9ySEVBRCB8fCB0aGlzLmlzUmVtb3RlVGFnO1xuICAgIHRoaXMuaXNMb2NhbCA9IHRoaXMuaXNMb2NhbEJyYW5jaCB8fCB0aGlzLmlzTG9jYWxUYWc7XG4gICAgaWYgKHRoaXMuaXNMb2NhbEJyYW5jaCkge1xuICAgICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3JlZnMvaGVhZHMvJy5sZW5ndGgpO1xuICAgICAgdGhpcy5yZWZOYW1lID0gdGhpcy5sb2NhbFJlZk5hbWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmVtb3RlQnJhbmNoKSB7XG4gICAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgncmVmcy9yZW1vdGVzLycubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNMb2NhbFRhZykge1xuICAgICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3RhZzogcmVmcy90YWdzLycubGVuZ3RoKTtcbiAgICAgIHRoaXMucmVmTmFtZSA9IHRoaXMubG9jYWxSZWZOYW1lO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1JlbW90ZVRhZykge1xuICAgICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3JlbW90ZS10YWc6ICcubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXRlZE5hbWUgPSB0aGlzLmxvY2FsUmVmTmFtZS5zcGxpdCgnLycpO1xuICAgIGlmICh0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAvLyBnZXQgcmlkIG9mIHRoZSBvcmlnaW4vIHBhcnQgb2Ygb3JpZ2luL2JyYW5jaG5hbWVcbiAgICAgIHRoaXMucmVtb3RlID0gc3BsaXRlZE5hbWVbMF07XG4gICAgICB0aGlzLnJlZk5hbWUgPSBzcGxpdGVkTmFtZS5zbGljZSgxKS5qb2luKCcvJyk7XG4gICAgfVxuICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgdGhpcy5zZXJ2ZXIgPSB0aGlzLmdyYXBoLnNlcnZlcjtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLmlzTG9jYWxCcmFuY2ggJiYgdGhpcy5ncmFwaC5jaGVja2VkT3V0QnJhbmNoKCkgPT0gdGhpcy5yZWZOYW1lKTtcbiAgICB0aGlzLmNvbG9yID0gdGhpcy5fY29sb3JGcm9tSGFzaE9mU3RyaW5nKHRoaXMubmFtZSk7XG5cbiAgICB0aGlzLm5vZGUuc3Vic2NyaWJlKG9sZE5vZGUgPT4ge1xuICAgICAgaWYgKG9sZE5vZGUpIG9sZE5vZGUucmVtb3ZlUmVmKHRoaXMpO1xuICAgIH0sIG51bGwsICdiZWZvcmVDaGFuZ2UnKTtcbiAgICB0aGlzLm5vZGUuc3Vic2NyaWJlKG5ld05vZGUgPT4ge1xuICAgICAgaWYgKG5ld05vZGUpIG5ld05vZGUucHVzaFJlZih0aGlzKTtcbiAgICB9KTtcblxuICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIGlzIGZvciBhdXRvY29tcGxldGUgZGlzcGxheVxuICAgIHRoaXMudmFsdWUgPSBzcGxpdGVkTmFtZVtzcGxpdGVkTmFtZS5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmxhYmVsID0gdGhpcy5sb2NhbFJlZk5hbWU7XG4gICAgdGhpcy5kb20gPSBgJHt0aGlzLmxvY2FsUmVmTmFtZX08c3Bhbj4ke29jdGljb25zWyh0aGlzLmlzVGFnID8gJ3RhZyc6ICdnaXQtYnJhbmNoJyldLnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pfTwvc3Bhbj5gO1xuXG4gICAgdGhpcy5kaXNwbGF5SHRtbCA9IChsYXJnZUN1cnJlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSAobGFyZ2VDdXJyZW50ICYmIHRoaXMuY3VycmVudCgpKSA/IDI2IDogMTg7XG4gICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICBpZiAodGhpcy5pc1JlbW90ZSkge1xuICAgICAgICBwcmVmaXggPSBgPHNwYW4+JHtvY3RpY29ucy5nbG9iZS50b1NWRyh7ICdoZWlnaHQnOiBzaXplIH0pfTwvc3Bhbj4gYDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQnJhbmNoKSB7XG4gICAgICAgIHByZWZpeCArPSBgPHNwYW4+JHtvY3RpY29uc1snZ2l0LWJyYW5jaCddLnRvU1ZHKHsgJ2hlaWdodCc6IHNpemUgfSl9PC9zcGFuPiBgO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVGFnKSB7XG4gICAgICAgIHByZWZpeCArPSBgPHNwYW4+JHtvY3RpY29ucy50YWcudG9TVkcoeyAnaGVpZ2h0Jzogc2l6ZSB9KX08L3NwYW4+IGA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZml4ICsgdGhpcy5sb2NhbFJlZk5hbWU7XG4gICAgfTtcbiAgfVxuXG4gIF9jb2xvckZyb21IYXNoT2ZTdHJpbmcoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAjJHttZDUoc3RyaW5nKS50b1N0cmluZygpLnNsaWNlKDAsIDYpfWA7XG4gIH1cblxuICBkcmFnU3RhcnQoKSB7XG4gICAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCh0aGlzKTtcbiAgICB0aGlzLmlzRHJhZ2dpbmcodHJ1ZSk7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICB9XG5cbiAgZHJhZ0VuZCgpIHtcbiAgICB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KG51bGwpO1xuICAgIHRoaXMuaXNEcmFnZ2luZyhmYWxzZSk7XG4gIH1cblxuICBtb3ZlVG8odGFyZ2V0LCByZXdpbmRXYXJuT3ZlcnJpZGUpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAodGhpcy5pc0xvY2FsKSB7XG4gICAgICBjb25zdCB0b05vZGUgPSB0aGlzLmdyYXBoLm5vZGVzQnlJZFt0YXJnZXRdO1xuICAgICAgY29uc3QgYXJncyA9IHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLnJlZk5hbWUsIHNoYTE6IHRhcmdldCwgZm9yY2U6IHRydWUsIHRvOiB0YXJnZXQsIG1vZGU6ICdoYXJkJyB9O1xuICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQoKSkge1xuICAgICAgICBvcGVyYXRpb24gPSAnL3Jlc2V0JztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RhZykge1xuICAgICAgICBvcGVyYXRpb24gPSAnL3RhZ3MnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BlcmF0aW9uID0gJy9icmFuY2hlcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmV3aW5kV2Fybk92ZXJyaWRlICYmIHRoaXMubm9kZSgpLmRhdGUgPiB0b05vZGUuZGF0ZSkge1xuICAgICAgICBwcm9taXNlID0gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZT8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gcG90ZW50aWFsbHkgZ29pbmcgYmFjayBpbiBoaXN0b3J5Lid9KVxuICAgICAgICAgIC5zaG93KClcbiAgICAgICAgICAuY2xvc2VUaGVuKGRpYWcgPT4ge1xuICAgICAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKG9wZXJhdGlvbiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2xvc2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKG9wZXJhdGlvbiwgYXJncyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHB1c2hSZXEgPSB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgcmVtb3RlOiB0aGlzLnJlbW90ZSwgcmVmU3BlYzogdGFyZ2V0LCByZW1vdGVCcmFuY2g6IHRoaXMucmVmTmFtZSB9O1xuICAgICAgcHJvbWlzZSA9IHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcHVzaCcsIHB1c2hSZXEpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIuZXJyb3JDb2RlID09PSAnbm9uLWZhc3QtZm9yd2FyZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnRm9yY2UgcHVzaD8nLCBkZXRhaWxzOiAnVGhlIHJlbW90ZSBicmFuY2ggY2FuXFwndCBiZSBmYXN0LWZvcndhcmRlZC4nIH0pXG4gICAgICAgICAgICAgIC5zaG93KClcbiAgICAgICAgICAgICAgLmNsb3NlVGhlbihkaWFnID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRpYWcucmVzdWx0KCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBwdXNoUmVxLmZvcmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9wdXNoJywgcHVzaFJlcSk7XG4gICAgICAgICAgICAgIH0pLmNsb3NlUHJvbWlzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZSh0YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ncmFwaC5jaGVja2VkT3V0QnJhbmNoKCkgPT0gdGhpcy5yZWZOYW1lKSB7XG4gICAgICAgICAgdGhpcy5ncmFwaC5IRUFEcmVmKCkubm9kZSh0YXJnZXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUodGFyZ2V0Tm9kZSk7XG4gICAgICB9KS5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgfVxuXG4gIHJlbW92ZShpc0NsaWVudE9ubHkpIHtcbiAgICBsZXQgdXJsID0gdGhpcy5pc1RhZyA/ICcvdGFncycgOiAnL2JyYW5jaGVzJztcbiAgICBpZiAodGhpcy5pc1JlbW90ZSkgdXJsID0gYC9yZW1vdGUke3VybH1gO1xuXG4gICAgcmV0dXJuIChpc0NsaWVudE9ubHkgPyBwcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuc2VydmVyLmRlbFByb21pc2UodXJsLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgcmVtb3RlOiB0aGlzLmlzUmVtb3RlID8gdGhpcy5yZW1vdGUgOiBudWxsLCBuYW1lOiB0aGlzLnJlZk5hbWUgfSkpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUoKSkgdGhpcy5ub2RlKCkucmVtb3ZlUmVmKHRoaXMpO1xuICAgICAgICB0aGlzLmdyYXBoLnJlZnMucmVtb3ZlKHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5ncmFwaC5yZWZzQnlSZWZOYW1lW3RoaXMubmFtZV07XG4gICAgICB9KS5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzQ2xpZW50T25seSkge1xuICAgICAgICAgIGlmICh1cmwgPT0gJy9yZW1vdGUvdGFncycpIHtcbiAgICAgICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ3JlcXVlc3QtZmV0Y2gtdGFncycgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2JyYW5jaC11cGRhdGVkJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgZ2V0TG9jYWxSZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhcGguZ2V0UmVmKHRoaXMuZ2V0TG9jYWxSZWZGdWxsTmFtZSgpLCBmYWxzZSk7XG4gIH1cblxuICBnZXRMb2NhbFJlZkZ1bGxOYW1lKCkge1xuICAgIGlmICh0aGlzLmlzUmVtb3RlQnJhbmNoKSByZXR1cm4gYHJlZnMvaGVhZHMvJHt0aGlzLnJlZk5hbWV9YDtcbiAgICBpZiAodGhpcy5pc1JlbW90ZVRhZykgcmV0dXJuIGB0YWc6ICR7dGhpcy5yZWZOYW1lfWA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRSZW1vdGVSZWYocmVtb3RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhcGguZ2V0UmVmKHRoaXMuZ2V0UmVtb3RlUmVmRnVsbE5hbWUocmVtb3RlKSwgZmFsc2UpO1xuICB9XG5cbiAgZ2V0UmVtb3RlUmVmRnVsbE5hbWUocmVtb3RlKSB7XG4gICAgaWYgKHRoaXMuaXNMb2NhbEJyYW5jaCkgcmV0dXJuIGByZWZzL3JlbW90ZXMvJHtyZW1vdGV9LyR7dGhpcy5yZWZOYW1lfWA7XG4gICAgaWYgKHRoaXMuaXNMb2NhbFRhZykgcmV0dXJuIGByZW1vdGUtdGFnOiAke3JlbW90ZX0vJHt0aGlzLnJlZk5hbWV9YDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNhbkJlUHVzaGVkKHJlbW90ZSkge1xuICAgIGlmICghdGhpcy5pc0xvY2FsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFyZW1vdGUpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByZW1vdGVSZWYgPSB0aGlzLmdldFJlbW90ZVJlZihyZW1vdGUpO1xuICAgIGlmICghcmVtb3RlUmVmKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKCkgIT0gcmVtb3RlUmVmLm5vZGUoKTtcbiAgfVxuXG4gIGNyZWF0ZVJlbW90ZVJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9wdXNoJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHJlbW90ZTogdGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCksIHJlZlNwZWM6IHRoaXMucmVmTmFtZSwgcmVtb3RlQnJhbmNoOiB0aGlzLnJlZk5hbWUgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgfVxuXG4gIGNoZWNrb3V0KCkge1xuICAgIGNvbnN0IGlzUmVtb3RlID0gdGhpcy5pc1JlbW90ZUJyYW5jaDtcbiAgICBjb25zdCBpc0xvY2FsQ3VycmVudCA9IHRoaXMuZ2V0TG9jYWxSZWYoKSAmJiB0aGlzLmdldExvY2FsUmVmKCkuY3VycmVudCgpO1xuXG4gICAgcmV0dXJuIHByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNSZW1vdGUgJiYgIWlzTG9jYWxDdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvYnJhbmNoZXMnLCB7XG4gICAgICAgICAgICBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLnJlZk5hbWUsXG4gICAgICAgICAgICBzaGExOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKCgpID0+IHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvY2hlY2tvdXQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgbmFtZTogdGhpcy5yZWZOYW1lIH0pKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNSZW1vdGUgJiYgaXNMb2NhbEN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXNldCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCB0bzogdGhpcy5uYW1lLCBtb2RlOiAnaGFyZCcgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmdyYXBoLkhFQURyZWYoKS5ub2RlKHRoaXMubm9kZSgpKTtcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgIT0gJ21lcmdlLWZhaWxlZCcpIHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlcnIpO1xuICAgICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWZWaWV3TW9kZWw7XG4iLCJjb25zdCBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbmNvbnN0IG9jdGljb25zID0gcmVxdWlyZSgnb2N0aWNvbnMnKTtcbmNvbnN0IGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG5jb25zdCBwcm9ncmFtRXZlbnRzID0gcmVxdWlyZSgndW5naXQtcHJvZ3JhbS1ldmVudHMnKTtcbmNvbnN0IEdpdE5vZGVWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2dpdC1ub2RlJyk7XG5jb25zdCBHaXRSZWZWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2dpdC1yZWYnKTtcbmNvbnN0IEVkZ2VWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2VkZ2UnKTtcbmNvbnN0IG51bWJlck9mTm9kZXNQZXJMb2FkID0gdW5naXQuY29uZmlnLm51bWJlck9mTm9kZXNQZXJMb2FkO1xuXG5jb21wb25lbnRzLnJlZ2lzdGVyKCdncmFwaCcsIGFyZ3MgPT4gbmV3IEdyYXBoVmlld01vZGVsKGFyZ3Muc2VydmVyLCBhcmdzLnJlcG9QYXRoKSk7XG5cbmNsYXNzIEdyYXBoVmlld01vZGVsIHtcbiAgY29uc3RydWN0b3Ioc2VydmVyLCByZXBvUGF0aCkge1xuICAgIHRoaXMuX21hcmtJZGVvbG9naWNhbFN0YW1wID0gMDtcbiAgICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gICAgdGhpcy5saW1pdCA9IGtvLm9ic2VydmFibGUobnVtYmVyT2ZOb2Rlc1BlckxvYWQpO1xuICAgIHRoaXMuc2tpcCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgdGhpcy5jdXJyZW50UmVtb3RlID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMubm9kZXMgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB0aGlzLmVkZ2VzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gICAgdGhpcy5yZWZzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gICAgdGhpcy5ub2Rlc0J5SWQgPSB7fTtcbiAgICB0aGlzLnJlZnNCeVJlZk5hbWUgPSB7fTtcbiAgICB0aGlzLmNoZWNrZWRPdXRCcmFuY2ggPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5jaGVja2VkT3V0UmVmID0ga28uY29tcHV0ZWQoKCkgPT4gdGhpcy5jaGVja2VkT3V0QnJhbmNoKCkgPyB0aGlzLmdldFJlZihgcmVmcy9oZWFkcy8ke3RoaXMuY2hlY2tlZE91dEJyYW5jaCgpfWApIDogbnVsbCk7XG4gICAgdGhpcy5IRUFEcmVmID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuSEVBRCA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMuSEVBRHJlZigpID8gdGhpcy5IRUFEcmVmKCkubm9kZSgpIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmNvbW1pdE5vZGVDb2xvciA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMuSEVBRCgpID8gdGhpcy5IRUFEKCkuY29sb3IoKSA6ICcjNEE0QTRBJyk7XG4gICAgdGhpcy5jb21taXROb2RlRWRnZSA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5IRUFEKCkgfHwgIXRoaXMuSEVBRCgpLmN4KCkgfHwgIXRoaXMuSEVBRCgpLmN5KCkpIHJldHVybjtcbiAgICAgIHJldHVybiBgTSA2MTAgNjggTCAke3RoaXMuSEVBRCgpLmN4KCl9ICR7dGhpcy5IRUFEKCkuY3koKX1gO1xuICAgIH0pO1xuICAgIHRoaXMuc2hvd0NvbW1pdE5vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0ID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuZWRnZXNCeUlkID0ge307XG4gICAgdGhpcy5zY3JvbGxlZFRvRW5kID0gXy5kZWJvdW5jZSgoKSA9PiB7XG4gICAgICB0aGlzLmxpbWl0KG51bWJlck9mTm9kZXNQZXJMb2FkICsgdGhpcy5saW1pdCgpKTtcbiAgICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaSgpO1xuICAgIH0sIDUwMCwgdHJ1ZSk7XG4gICAgdGhpcy5sb2FkQWhlYWQgPSBfLmRlYm91bmNlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNraXAoKSA8PSAwKSByZXR1cm47XG4gICAgICB0aGlzLnNraXAoTWF0aC5tYXgodGhpcy5za2lwKCkgLSBudW1iZXJPZk5vZGVzUGVyTG9hZCwgMCkpO1xuICAgICAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gICAgfSwgNTAwLCB0cnVlKTtcbiAgICB0aGlzLmNvbW1pdE9wYWNpdHkgPSBrby5vYnNlcnZhYmxlKDEuMCk7XG4gICAgdGhpcy5oZWlnaHN0QnJhbmNoT3JkZXIgPSAwO1xuICAgIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYy5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmRlc3Ryb3kpXG4gICAgICAgIHZhbHVlLmRlc3Ryb3koKTtcbiAgICB9LCBudWxsLCAnYmVmb3JlQ2hhbmdlJyk7XG5cbiAgICB0aGlzLmhvdmVyR3JhcGhBY3Rpb24gPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY3JlYXRlSG92ZXJHcmFwaGljKSB7XG4gICAgICAgIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWModmFsdWUuY3JlYXRlSG92ZXJHcmFwaGljKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYyhudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCA9IF8udGhyb3R0bGUodGhpcy5sb2FkTm9kZXNGcm9tQXBpLmJpbmQodGhpcyksIDEwMDApO1xuICAgIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMudXBkYXRlQnJhbmNoZXMuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gICAgdGhpcy51cGRhdGVCcmFuY2hlcygpO1xuICAgIHRoaXMuZ3JhcGhXaWR0aCA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLmdyYXBoSGVpZ2h0ID0ga28ub2JzZXJ2YWJsZSg4MDApO1xuICAgIHRoaXMuc2VhcmNoSWNvbiA9IG9jdGljb25zLnNlYXJjaC50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KTtcbiAgICB0aGlzLnBsdXNJY29uID0gb2N0aWNvbnMucGx1cy50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KTtcbiAgfVxuXG4gIHVwZGF0ZU5vZGUocGFyZW50RWxlbWVudCkge1xuICAgIGtvLnJlbmRlclRlbXBsYXRlKCdncmFwaCcsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIGdldE5vZGUoc2hhMSwgbG9nRW50cnkpIHtcbiAgICBsZXQgbm9kZVZpZXdNb2RlbCA9IHRoaXMubm9kZXNCeUlkW3NoYTFdO1xuICAgIGlmICghbm9kZVZpZXdNb2RlbCkgbm9kZVZpZXdNb2RlbCA9IHRoaXMubm9kZXNCeUlkW3NoYTFdID0gbmV3IEdpdE5vZGVWaWV3TW9kZWwodGhpcywgc2hhMSk7XG4gICAgaWYgKGxvZ0VudHJ5KSBub2RlVmlld01vZGVsLnNldERhdGEobG9nRW50cnkpO1xuICAgIHJldHVybiBub2RlVmlld01vZGVsO1xuICB9XG5cbiAgZ2V0UmVmKHJlZiwgY29uc3RydWN0SWZVbmF2YWlsYWJsZSkge1xuICAgIGlmIChjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlID09PSB1bmRlZmluZWQpIGNvbnN0cnVjdElmVW5hdmFpbGFibGUgPSB0cnVlO1xuICAgIGxldCByZWZWaWV3TW9kZWwgPSB0aGlzLnJlZnNCeVJlZk5hbWVbcmVmXTtcbiAgICBpZiAoIXJlZlZpZXdNb2RlbCAmJiBjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlKSB7XG4gICAgICByZWZWaWV3TW9kZWwgPSB0aGlzLnJlZnNCeVJlZk5hbWVbcmVmXSA9IG5ldyBHaXRSZWZWaWV3TW9kZWwocmVmLCB0aGlzKTtcbiAgICAgIHRoaXMucmVmcy5wdXNoKHJlZlZpZXdNb2RlbCk7XG4gICAgICBpZiAocmVmVmlld01vZGVsLm5hbWUgPT09ICdIRUFEJykge1xuICAgICAgICB0aGlzLkhFQURyZWYocmVmVmlld01vZGVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZlZpZXdNb2RlbDtcbiAgfVxuXG4gIGxvYWROb2Rlc0Zyb21BcGkoKSB7XG4gICAgY29uc3Qgbm9kZVNpemUgPSB0aGlzLm5vZGVzKCkubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VydmVyLmdldFByb21pc2UoJy9naXRsb2cnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgbGltaXQ6IHRoaXMubGltaXQoKSwgc2tpcDogdGhpcy5za2lwKCkgfSlcbiAgICAgIC50aGVuKGxvZyA9PiB7XG4gICAgICAgIC8vIHNldCBuZXcgbGltaXQgYW5kIHNraXBcbiAgICAgICAgdGhpcy5saW1pdChwYXJzZUludChsb2cubGltaXQpKTtcbiAgICAgICAgdGhpcy5za2lwKHBhcnNlSW50KGxvZy5za2lwKSk7XG4gICAgICAgIHJldHVybiBsb2cubm9kZXMgfHwgW107XG4gICAgICB9KS50aGVuKG5vZGVzID0+IC8vIGNyZWF0ZSBhbmQvb3IgY2FsY3VsYXRlIG5vZGVzXG4gICAgdGhpcy5jb21wdXRlTm9kZShub2Rlcy5tYXAoKGxvZ0VudHJ5KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROb2RlKGxvZ0VudHJ5LnNoYTEsIGxvZ0VudHJ5KTsgICAgIC8vIGNvbnZlcnQgdG8gbm9kZSBvYmplY3RcbiAgICB9KSkpLnRoZW4obm9kZXMgPT4ge1xuICAgICAgICAvLyBjcmVhdGUgZWRnZXNcbiAgICAgICAgY29uc3QgZWRnZXMgPSBbXTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBub2RlLnBhcmVudHMoKS5mb3JFYWNoKHBhcmVudFNoYTEgPT4ge1xuICAgICAgICAgICAgZWRnZXMucHVzaCh0aGlzLmdldEVkZ2Uobm9kZS5zaGExLCBwYXJlbnRTaGExKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZS5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lZGdlcyhlZGdlcyk7XG4gICAgICAgIHRoaXMubm9kZXMobm9kZXMpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuZ3JhcGhIZWlnaHQobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uY3koKSArIDgwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoV2lkdGgoMTAwMCArICh0aGlzLmhlaWdoc3RCcmFuY2hPcmRlciAqIDkwKSk7XG4gICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2luaXQtdG9vbHRpcCcgfSk7XG4gICAgICB9KS5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5ncmFwaEhlaWdodCgpID4gMCAmJiBub2RlU2l6ZSAhPSB0aGlzLm5vZGVzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxlZFRvRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgdHJhdmVyc2VOb2RlTGVmdFBhcmVudHMobm9kZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayhub2RlKTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLm5vZGVzQnlJZFtub2RlLnBhcmVudHMoKVswXV07XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy50cmF2ZXJzZU5vZGVMZWZ0UGFyZW50cyhwYXJlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBjb21wdXRlTm9kZShub2Rlcykge1xuICAgIG5vZGVzID0gbm9kZXMgfHwgdGhpcy5ub2RlcygpO1xuXG4gICAgdGhpcy5tYXJrTm9kZXNJZGVvbG9naWNhbEJyYW5jaGVzKHRoaXMucmVmcygpLCBub2RlcywgdGhpcy5ub2Rlc0J5SWQpO1xuXG4gICAgY29uc3QgdXBkYXRlVGltZVN0YW1wID0gbW9tZW50KCkudmFsdWVPZigpO1xuICAgIGlmICh0aGlzLkhFQUQoKSkge1xuICAgICAgdGhpcy50cmF2ZXJzZU5vZGVMZWZ0UGFyZW50cyh0aGlzLkhFQUQoKSwgbm9kZSA9PiB7XG4gICAgICAgIG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPSB1cGRhdGVUaW1lU3RhbXA7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgb3V0IG5vZGVzIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIGJyYW5jaCAoc3RhZ2luZyBhbmQgb3JwaGFuZWQgbm9kZXMpXG4gICAgbm9kZXMgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiAobm9kZS5pZGVvbG9naWNhbEJyYW5jaCgpICYmICFub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCkuaXNTdGFzaCkgfHwgbm9kZS5hbmNlc3Rvck9mSEVBRFRpbWVTdGFtcCA9PSB1cGRhdGVUaW1lU3RhbXApO1xuXG4gICAgbGV0IGJyYW5jaFNsb3RDb3VudGVyID0gdGhpcy5IRUFEKCkgPyAxIDogMDtcblxuICAgIC8vIFRoZW4gaXRlcmF0ZSBmcm9tIHRoZSBib3R0b20gdG8gZml4IHRoZSBvcmRlcnMgb2YgdGhlIGJyYW5jaGVzXG4gICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5hbmNlc3Rvck9mSEVBRFRpbWVTdGFtcCA9PSB1cGRhdGVUaW1lU3RhbXApIGNvbnRpbnVlO1xuICAgICAgY29uc3QgaWRlb2xvZ2ljYWxCcmFuY2ggPSBub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCk7XG5cbiAgICAgIC8vIEZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGJyYW5jaCwgZmluZCBhbiBlbXB0eSBzbG90IGZvciB0aGUgYnJhbmNoXG4gICAgICBpZiAoaWRlb2xvZ2ljYWxCcmFuY2gubGFzdFNsb3R0ZWRUaW1lU3RhbXAgIT0gdXBkYXRlVGltZVN0YW1wKSB7XG4gICAgICAgIGlkZW9sb2dpY2FsQnJhbmNoLmxhc3RTbG90dGVkVGltZVN0YW1wID0gdXBkYXRlVGltZVN0YW1wO1xuICAgICAgICBpZGVvbG9naWNhbEJyYW5jaC5icmFuY2hPcmRlciA9IGJyYW5jaFNsb3RDb3VudGVyKys7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuYnJhbmNoT3JkZXIoaWRlb2xvZ2ljYWxCcmFuY2guYnJhbmNoT3JkZXIpO1xuICAgIH1cblxuICAgIHRoaXMuaGVpZ2hzdEJyYW5jaE9yZGVyID0gYnJhbmNoU2xvdENvdW50ZXIgLSAxO1xuICAgIGxldCBwcmV2Tm9kZTtcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbm9kZS5hbmNlc3Rvck9mSEVBRChub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID09IHVwZGF0ZVRpbWVTdGFtcCk7XG4gICAgICBpZiAobm9kZS5hbmNlc3Rvck9mSEVBRCgpKSBub2RlLmJyYW5jaE9yZGVyKDApO1xuICAgICAgbm9kZS5hYm92ZU5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgIGlmIChwcmV2Tm9kZSkgcHJldk5vZGUuYmVsb3dOb2RlID0gbm9kZTtcbiAgICAgIHByZXZOb2RlID0gbm9kZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGdldEVkZ2Uobm9kZUFzaGExLCBub2RlQnNoYTEpIHtcbiAgICBjb25zdCBpZCA9IGAke25vZGVBc2hhMX0tJHtub2RlQnNoYTF9YDtcbiAgICBsZXQgZWRnZSA9IHRoaXMuZWRnZXNCeUlkW2lkXTtcbiAgICBpZiAoIWVkZ2UpIHtcbiAgICAgIGVkZ2UgPSB0aGlzLmVkZ2VzQnlJZFtpZF0gPSBuZXcgRWRnZVZpZXdNb2RlbCh0aGlzLCBub2RlQXNoYTEsIG5vZGVCc2hhMSk7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9XG5cbiAgbWFya05vZGVzSWRlb2xvZ2ljYWxCcmFuY2hlcyhyZWZzLCBub2Rlcywgbm9kZXNCeUlkKSB7XG4gICAgcmVmcyA9IHJlZnMuZmlsdGVyKHIgPT4gISFyLm5vZGUoKSk7XG4gICAgcmVmcyA9IHJlZnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuaXNMb2NhbCAmJiAhYi5pc0xvY2FsKSByZXR1cm4gLTE7XG4gICAgICBpZiAoYi5pc0xvY2FsICYmICFhLmlzTG9jYWwpIHJldHVybiAxO1xuICAgICAgaWYgKGEuaXNCcmFuY2ggJiYgIWIuaXNCcmFuY2gpIHJldHVybiAtMTtcbiAgICAgIGlmIChiLmlzQnJhbmNoICYmICFhLmlzQnJhbmNoKSByZXR1cm4gMTtcbiAgICAgIGlmIChhLmlzSEVBRCAmJiAhYi5pc0hFQUQpIHJldHVybiAxO1xuICAgICAgaWYgKCFhLmlzSEVBRCAmJiBiLmlzSEVBRCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGEuaXNTdGFzaCAmJiAhYi5pc1N0YXNoKSByZXR1cm4gMTtcbiAgICAgIGlmIChiLmlzU3Rhc2ggJiYgIWEuaXNTdGFzaCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGEubm9kZSgpICYmIGEubm9kZSgpLmRhdGUgJiYgYi5ub2RlKCkgJiYgYi5ub2RlKCkuZGF0ZSlcbiAgICAgICAgcmV0dXJuIGEubm9kZSgpLmRhdGUgLSBiLm5vZGUoKS5kYXRlO1xuICAgICAgcmV0dXJuIGEucmVmTmFtZSA8IGIucmVmTmFtZSA/IC0xIDogMTtcbiAgICB9KTtcbiAgICBjb25zdCBzdGFtcCA9IHRoaXMuX21hcmtJZGVvbG9naWNhbFN0YW1wKys7XG4gICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICB0aGlzLnRyYXZlcnNlTm9kZVBhcmVudHMocmVmLm5vZGUoKSwgbm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLnN0YW1wID09IHN0YW1wKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG5vZGUuc3RhbXAgPSBzdGFtcDtcbiAgICAgICAgbm9kZS5pZGVvbG9naWNhbEJyYW5jaChyZWYpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdHJhdmVyc2VOb2RlUGFyZW50cyhub2RlLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSkpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucGFyZW50cygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBpZiBwYXJlbnQsIHRyYXZlcnMgcGFyZW50XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLm5vZGVzQnlJZFtub2RlLnBhcmVudHMoKVtpXV07XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHRoaXMudHJhdmVyc2VOb2RlUGFyZW50cyhwYXJlbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVCdWJibGVkQ2xpY2soZWxlbSwgZXZlbnQpIHtcbiAgICAvLyBJZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIGJvdW5kIHRvIHRoZSBjdXJyZW50IGFjdGlvbiBjb250ZXh0LFxuICAgIC8vIHRoZW4gbGV0J3Mgbm90IGRlc2VsZWN0IGl0LlxuICAgIGlmIChrby5kYXRhRm9yKGV2ZW50LnRhcmdldCkgPT09IHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgJiYgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgR2l0Tm9kZVZpZXdNb2RlbCkge1xuICAgICAgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpLnRvZ2dsZVNlbGVjdGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQobnVsbCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBjbGljayB3YXMgb24gYW4gaW5wdXQgZWxlbWVudCwgdGhlbiBsZXQncyBhbGxvdyB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gcHJvY2VlZC5cbiAgICAvLyBUaGlzIGlzIGVzcGVjaWFsbHkgbmVlZGVkIHNpbmNlIGZvciBzb21lIHN0cmFuZ2UgcmVhc29uIGFueSBzdWJtaXQgKGllLiBlbnRlciBpbiBhIHRleHRib3gpXG4gICAgLy8gd2lsbCB0cmlnZ2VyIGEgY2xpY2sgZXZlbnQgb24gdGhlIHN1Ym1pdCBpbnB1dCBvZiB0aGUgZm9ybSwgd2hpY2ggd2lsbCBlbmQgdXAgaGVyZSxcbiAgICAvLyBhbmQgaWYgd2UgZG9uJ3QgcmV0dXJuIHRydWUsIHRoZW4gdGhlIHN1Ym1pdCBldmVudCBpcyBuZXZlciBmaXJlZCwgYnJlYWtpbmcgc3R1ZmYuXG4gICAgaWYgKGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvblByb2dyYW1FdmVudChldmVudCkge1xuICAgIGlmIChldmVudC5ldmVudCA9PSAnZ2l0LWRpcmVjdG9yeS1jaGFuZ2VkJykge1xuICAgICAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpVGhyb3R0bGVkKCk7XG4gICAgICB0aGlzLnVwZGF0ZUJyYW5jaGVzVGhyb3R0bGVkKCk7XG4gICAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVxdWVzdC1hcHAtY29udGVudC1yZWZyZXNoJykge1xuICAgICAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpVGhyb3R0bGVkKCk7XG4gICAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVtb3RlLXRhZ3MtdXBkYXRlJykge1xuICAgICAgdGhpcy5zZXRSZW1vdGVUYWdzKGV2ZW50LnRhZ3MpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuZXZlbnQgPT0gJ2N1cnJlbnQtcmVtb3RlLWNoYW5nZWQnKSB7XG4gICAgICB0aGlzLmN1cnJlbnRSZW1vdGUoZXZlbnQubmV3UmVtb3RlKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdncmFwaC1yZW5kZXInKSB7XG4gICAgICB0aGlzLm5vZGVzKCkuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgbm9kZS5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUFuaW1hdGlvbkZyYW1lKGRlbHRhVCkge1xuICAgIHRoaXMubm9kZXMoKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbm9kZS51cGRhdGVBbmltYXRpb25GcmFtZShkZWx0YVQpO1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQnJhbmNoZXMoKSB7XG4gICAgdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL2NoZWNrb3V0JywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCkgfSlcbiAgICAgIC50aGVuKHJlcyA9PiB7IHRoaXMuY2hlY2tlZE91dEJyYW5jaChyZXMpOyB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIuZXJyb3JDb2RlICE9ICdub3QtYS1yZXBvc2l0b3J5JykgdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIHNldFJlbW90ZVRhZ3MocmVtb3RlVGFncykge1xuICAgIGNvbnN0IHZlcnNpb24gPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3Qgc2hhMU1hcCA9IHt9OyAvLyBtYXAgaG9sZGluZyB0cnVlIHNoYTEgcGVyIHRhZ3NcbiAgICByZW1vdGVUYWdzLmZvckVhY2godGFnID0+IHtcbiAgICAgIGlmICh0YWcubmFtZS5pbmNsdWRlcygnXnt9JykpIHtcbiAgICAgICAgLy8gVGhpcyB0YWcgaXMgYSBkZXJlZmVyZW5jZSB0YWcsIHVzZSB0aGlzIHNoYTEuXG4gICAgICAgIGNvbnN0IHRhZ1JlZiA9IHRhZy5uYW1lLnNsaWNlKDAsIHRhZy5uYW1lLmxlbmd0aCAtICdee30nLmxlbmd0aCk7XG4gICAgICAgIHNoYTFNYXBbdGFnUmVmXSA9IHRhZy5zaGExO1xuICAgICAgfSBlbHNlIGlmICghc2hhMU1hcFt0YWcubmFtZV0pIHtcbiAgICAgICAgLy8gSWYgc2hhMSB3YXNuJ3QgcHJldmlvdXNseSBzZXQsIHVzZSB0aGlzIHNoYTFcbiAgICAgICAgc2hhMU1hcFt0YWcubmFtZV0gPSB0YWcuc2hhMTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlbW90ZVRhZ3MuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBpZiAoIXJlZi5uYW1lLmluY2x1ZGVzKCdee30nKSkge1xuICAgICAgICBjb25zdCBuYW1lID0gYHJlbW90ZS10YWc6ICR7cmVmLnJlbW90ZX0vJHtyZWYubmFtZS5zcGxpdCgnLycpWzJdfWA7XG4gICAgICAgIHRoaXMuZ2V0UmVmKG5hbWUpLm5vZGUodGhpcy5nZXROb2RlKHNoYTFNYXBbcmVmLm5hbWVdKSk7XG4gICAgICAgIHRoaXMuZ2V0UmVmKG5hbWUpLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVmcygpLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgLy8gdGFnIGlzIHJlbW92ZWQgZnJvbSBhbm90aGVyIHNvdXJjZVxuICAgICAgaWYgKHJlZi5pc1JlbW90ZVRhZyAmJiAoIXJlZi52ZXJzaW9uIHx8IHJlZi52ZXJzaW9uIDwgdmVyc2lvbikpIHtcbiAgICAgICAgcmVmLnJlbW92ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNoZWNrSGVhZE1vdmUodG9Ob2RlKSB7XG4gICAgaWYgKHRoaXMuSEVBRCgpID09PSB0b05vZGUpIHtcbiAgICAgIHRoaXMuSEVBRHJlZi5ub2RlKHRvTm9kZSk7XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBnZXRFZGdlTW9kZWxXaXRoRCA9IChkLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VEYXNoYXJyYXksIG1hcmtlckVuZCkgPT4gKHtcbiAgZCxcbiAgc3Ryb2tlOiBzdHJva2UgPyBzdHJva2UgOiAnIzRBNEE0QScsXG4gIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA/IHN0cm9rZVdpZHRoIDogJzgnLFxuICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSA/IHN0cm9rZURhc2hhcnJheSA6ICcxMCwgNScsXG4gIG1hcmtlckVuZDogbWFya2VyRW5kID8gbWFya2VyRW5kIDogJydcbn0pO1xuY29uc3QgZ2V0RWRnZU1vZGVsID0gKHNjeCwgc2N5LCB0Y3gsIHRjeSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5LCBtYXJrZXJFbmQpID0+IHtcbiAgcmV0dXJuIGdldEVkZ2VNb2RlbFdpdGhEKGBNICR7c2N4fSAke3NjeX0gTCAke3RjeH0gJHt0Y3l9YCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5LCBtYXJrZXJFbmQpO1xufVxuY29uc3QgZ2V0Tm9kZU1vZGVsID0gKGN4LCBjeSwgciwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5KSA9PiAoe1xuICBjeCxcbiAgY3ksXG4gIHIsXG4gIGZpbGwsXG4gIHN0cm9rZTogc3Ryb2tlID8gc3Ryb2tlIDogJyM0MURFM0MnLFxuICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggPyBzdHJva2VXaWR0aCA6ICc4JyxcbiAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXkgPyBzdHJva2VEYXNoYXJyYXkgOiAnMTAsIDUnXG59KTtcblxuY2xhc3MgSG92ZXJWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJnRWRnZXMgPSBbXTtcbiAgICB0aGlzLm5vZGVzID0gW107XG4gICAgdGhpcy5mZ0VkZ2VzID0gW107XG4gIH1cbn1cblxuY2xhc3MgTWVyZ2VWaWV3TW9kZWwgZXh0ZW5kcyBIb3ZlclZpZXdNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoLCBoZWFkTm9kZSwgbm9kZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuYmdFZGdlcyA9IFsgZ2V0RWRnZU1vZGVsKGhlYWROb2RlLmN4KCksIChoZWFkTm9kZS5jeSgpIC0gMTEwKSwgaGVhZE5vZGUuY3goKSwgaGVhZE5vZGUuY3koKSksXG4gICAgICAgICAgICAgICAgICBnZXRFZGdlTW9kZWwoaGVhZE5vZGUuY3goKSwgKGhlYWROb2RlLmN5KCkgLSAxMTApLCBub2RlLmN4KCksIG5vZGUuY3koKSkgXTtcbiAgICB0aGlzLm5vZGVzID0gWyBnZXROb2RlTW9kZWwoaGVhZE5vZGUuY3goKSwgaGVhZE5vZGUuY3koKSAtIDExMCwgTWF0aC5tYXgoaGVhZE5vZGUucigpLCBub2RlLnIoKSksICcjMjUyODMzJywgJyM0MURFM0MnLCAnOCcsICcxMCwgNScpIF07XG5cbiAgICBncmFwaC5jb21taXRPcGFjaXR5KDAuMSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ3JhcGguY29tbWl0T3BhY2l0eSgxLjApO1xuICB9XG59XG5cbmV4cG9ydHMuTWVyZ2VWaWV3TW9kZWwgPSBNZXJnZVZpZXdNb2RlbDtcblxuY2xhc3MgUmViYXNlVmlld01vZGVsIGV4dGVuZHMgSG92ZXJWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3RvcihvbnRvLCBub2Rlc1RoYXRXaWxsTW92ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgbm9kZXNUaGF0V2lsbE1vdmUgPSBub2Rlc1RoYXRXaWxsTW92ZS5zbGljZSgwLCAtMSk7XG5cbiAgICBpZiAobm9kZXNUaGF0V2lsbE1vdmUubGVuZ3RoID09IDApIHJldHVybjtcblxuICAgIHRoaXMuYmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbChvbnRvLmN4KCksIG9udG8uY3koKSwgb250by5jeCgpLCBvbnRvLmN5KCkgLSA2MCkpO1xuICAgIG5vZGVzVGhhdFdpbGxNb3ZlLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGN5ID0gb250by5jeSgpICsgKC05MCAqIChpICsgMSkpO1xuICAgICAgdGhpcy5ub2Rlcy5wdXNoKGdldE5vZGVNb2RlbChvbnRvLmN4KCksIGN5LCAyOCwgJ3RyYW5zcGFyZW50JykpO1xuICAgICAgaWYgKGkgKyAxIDwgbm9kZXNUaGF0V2lsbE1vdmUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbChvbnRvLmN4KCksIChjeSAtIDI1KSwgb250by5jeCgpLCAoY3kgLSA2NSkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5SZWJhc2VWaWV3TW9kZWwgPSBSZWJhc2VWaWV3TW9kZWw7XG5cbmNsYXNzIFJlc2V0Vmlld01vZGVsIGV4dGVuZHMgSG92ZXJWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3Rvcihub2Rlcykge1xuICAgIHN1cGVyKCk7XG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIHRoaXMuZmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbFdpdGhEKG5vZGUuZ2V0TGVmdFRvUmlnaHRTdHJpa2UoKSwgJ3JnYigyNTUsIDEyOSwgMzEpJywgJzgnLCAnMCwgMCcpKVxuICAgICAgdGhpcy5mZ0VkZ2VzLnB1c2goZ2V0RWRnZU1vZGVsV2l0aEQobm9kZS5nZXRSaWdodFRvTGVmdFN0cmlrZSgpLCAncmdiKDI1NSwgMTI5LCAzMSknLCAnOCcsICcwLCAwJykpO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLlJlc2V0Vmlld01vZGVsID0gUmVzZXRWaWV3TW9kZWw7XG5cbmNsYXNzIFB1c2hWaWV3TW9kZWwgZXh0ZW5kcyBIb3ZlclZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mZ0VkZ2VzID0gW2dldEVkZ2VNb2RlbChmcm9tTm9kZS5jeCgpLCBmcm9tTm9kZS5jeSgpLCB0b05vZGUuY3goKSwgKHRvTm9kZS5jeSgpICsgNDApLCAncmdiKDYxLCAxMzksIDI1NSknLCAnMTUnLCAnMTAsIDUnLCAndXJsKCNwdXNoQXJyb3dFbmQpJyApXTtcbiAgfVxufVxuZXhwb3J0cy5QdXNoVmlld01vZGVsID0gUHVzaFZpZXdNb2RlbDtcblxuY2xhc3MgU3F1YXNoVmlld01vZGVsIGV4dGVuZHMgSG92ZXJWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3Rvcihmcm9tLCBvbnRvKSB7XG4gICAgc3VwZXIoKTtcbiAgICBsZXQgcGF0aCA9IGZyb20uZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3Iob250byk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGggPT0gMSkge1xuICAgICAgcGF0aCA9IG9udG8uZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IoZnJvbSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2Rlcy5wdXNoKGdldE5vZGVNb2RlbChvbnRvLmN4KCksIG9udG8uY3koKSAtIDEyMCwgMjgsICd0cmFuc3BhcmVudCcpKTtcbiAgICB9XG5cbiAgICBwYXRoLnNsaWNlKDAsIC0xKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICB0aGlzLm5vZGVzLnB1c2goZ2V0Tm9kZU1vZGVsKG5vZGUuY3goKSwgbm9kZS5jeSgpLCBub2RlLnIoKSArIDIsICdyZ2JhKDEwMCwgNjAsIDIyMiwgMC44KScpKTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5TcXVhc2hWaWV3TW9kZWwgPSBTcXVhc2hWaWV3TW9kZWw7XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5jbGFzcyBTZWxlY3RhYmxlIHtcbiAgY29uc3RydWN0b3IoZ3JhcGgpIHtcbiAgICB0aGlzLnNlbGVjdGVkID0ga28uY29tcHV0ZWQoe1xuICAgICAgcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIGdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gdGhpcztcbiAgICAgIH0sXG4gICAgICB3cml0ZSh2YWwpIHtcbiAgICAgICAgLy8gdmFsIGlzIHRoaXMgaWYgd2UncmUgY2FsbGVkIGZyb20gYSBjbGljayBrbyBiaW5kaW5nXG4gICAgICAgIGlmICh2YWwgPT09IHRoaXMgfHwgdmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQodGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSB0aGlzKSB7XG4gICAgICAgICAgZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGFibGU7XG4iXX0=
