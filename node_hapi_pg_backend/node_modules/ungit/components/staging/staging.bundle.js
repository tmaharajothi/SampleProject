(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const ko = require('knockout');
const _ = require('lodash');
const promise = require('bluebird');
const octicons = require('octicons');
const components = require('ungit-components');
const programEvents = require('ungit-program-events');
const filesToDisplayIncrmentBy = 50;
const filesToDisplayLimit = filesToDisplayIncrmentBy;
const mergeTool = ungit.config.mergeTool;

components.register('staging', args => new StagingViewModel(args.server, args.repoPath, args.graph));

class StagingViewModel {
  constructor(server, repoPath, graph) {
    this.server = server;
    this.repoPath = repoPath;
    this.graph = graph;
    this.filesByPath = {};
    this.files = ko.observableArray();
    this.commitMessageTitleCount = ko.observable(0);
    this.commitMessageTitle = ko.observable();
    this.commitMessageTitle.subscribe(value => {
      this.commitMessageTitleCount(value.length);
    });
    this.commitMessageBody = ko.observable();
    this.wordWrap = components.create('textdiff.wordwrap');
    this.textDiffType = components.create('textdiff.type');
    this.whiteSpace = components.create('textdiff.whitespace');
    this.inRebase = ko.observable(false);
    this.inMerge = ko.observable(false);
    this.inCherry = ko.observable(false);
    this.conflictText = ko.computed(() => {
      if (this.inMerge()) {
        this.conflictContinue = this.conflictResolution.bind(this, '/merge/continue');
        this.conflictAbort = this.conflictResolution.bind(this, '/merge/abort');
        return 'Merge';
      } else if (this.inRebase()) {
        this.conflictContinue = this.conflictResolution.bind(this, '/rebase/continue');
        this.conflictAbort = this.conflictResolution.bind(this, '/rebase/abort');
        return 'Rebase';
      } else if (this.inCherry()) {
        this.conflictContinue = this.commit;
        this.conflictAbort = this.discardAllChanges;
        return 'Cherry-pick';
      } else {
        this.conflictContinue = undefined;
        this.conflictAbort = undefined;
        return undefined;
      }
    });
    this.HEAD = ko.observable();
    this.isStageValid = ko.computed(() => !this.inRebase() && !this.inMerge() && !this.inCherry());
    this.nFiles = ko.computed(() => this.files().length);
    this.nStagedFiles = ko.computed(() => this.files().filter(f => f.editState() === 'staged').length);
    this.allStageFlag = ko.computed(() => this.nFiles() !== this.nStagedFiles());
    this.stats = ko.computed(() => `${this.nFiles()} files, ${this.nStagedFiles()} to be commited`);
    this.amend = ko.observable(false);
    this.canAmend = ko.computed(() => this.HEAD() && !this.inRebase() && !this.inMerge() && !this.emptyCommit());
    this.emptyCommit = ko.observable(false);
    this.canEmptyCommit = ko.computed(() => this.HEAD() && !this.inRebase() && !this.inMerge());
    this.canStashAll = ko.computed(() => !this.amend());
    this.canPush = ko.computed(() => !!this.graph.currentRemote());
    this.showNux = ko.computed(() => this.files().length == 0 && !this.amend() && !this.inRebase() && !this.emptyCommit());
    this.showCancelButton = ko.computed(() => this.amend() || this.emptyCommit());
    this.commitValidationError = ko.computed(() => {
      if (this.conflictText()) {
        if (this.files().some((file) => file.conflict())) return 'Files in conflict';
      } else {
        if (!this.emptyCommit() && !this.amend() && !this.files().some((file) => file.editState() === 'staged' || file.editState() === 'patched')) {
          return 'No files to commit';
        }
        if (!this.commitMessageTitle()) {
          return 'Provide a title';
        }

        if (this.textDiffType.value() === 'sidebysidediff') {
          const patchFiles = this.files().filter(file => file.editState() === 'patched');
          if (patchFiles.length > 0) return 'Cannot patch with side by side view.';
        }
      }
      return '';
    });
    this.toggleSelectAllGlyphClass = ko.computed(() => {
      if (this.allStageFlag()) return 'glyphicon-unchecked';
      else return 'glyphicon-check';
    });

    this.refreshContentThrottled = _.throttle(this.refreshContent.bind(this), 400, { trailing: true });
    this.invalidateFilesDiffsThrottled = _.throttle(this.invalidateFilesDiffs.bind(this), 400, { trailing: true });
    this.refreshContentThrottled();
    this.loadAnyway = false;
    this.isDiagOpen = false;
    this.mutedTime = null;
    this.discardAllIcon = octicons.trashcan.toSVG({ 'height': 15 });
    this.stashIcon = octicons.pin.toSVG({ 'height': 15 });
    this.discardIcon = octicons.x.toSVG({ 'height': 18 });
    this.ignoreIcon = octicons.skip.toSVG({ 'height': 18 });
  }

  updateNode(parentElement) {
    ko.renderTemplate('staging', this, {}, parentElement);
  }

  onProgramEvent(event) {
    if (event.event == 'request-app-content-refresh') {
      this.refreshContent();
      this.invalidateFilesDiffs();
    }
    if (event.event == 'working-tree-changed') {
      this.refreshContentThrottled();
      this.invalidateFilesDiffsThrottled();
    }
  }

  refreshContent() {
    return promise.all([this.server.getPromise('/head', { path: this.repoPath(), limit: 1 })
        .then(log => {
          if (log.length > 0) {
            const array = log[0].message.split('\n');
            this.HEAD({title: array[0], body: array.slice(2).join('\n')});
          }
          else this.HEAD(null);
        }).catch(err => {
          if (err.errorCode != 'must-be-in-working-tree' && err.errorCode != 'no-such-path') {
            this.server.unhandledRejection(err);
          }
        }),
      this.server.getPromise('/status', { path: this.repoPath(), fileLimit: filesToDisplayLimit })
        .then(status => {
          if (Object.keys(status.files).length > filesToDisplayLimit && !this.loadAnyway) {
            if (this.isDiagOpen) {
              return;
            }
            this.isDiagOpen = true;
            return components.create('toomanyfilesdialogviewmodel', { title: 'Too many unstaged files', details: 'It is recommended to use command line as ungit may be too slow.'})
              .show()
              .closeThen(diag => {
                this.isDiagOpen = false;
                if (diag.result()) {
                  this.loadAnyway = true;
                  this.loadStatus(status);
                } else {
                  window.location.href = '/#/';
                }
              });
          } else {
            this.loadStatus(status);
          }
        }).catch(err => {
          if (err.errorCode != 'must-be-in-working-tree' && err.errorCode != 'no-such-path') {
            this.server.unhandledRejection(err);
          }
        })]);
  }

  loadStatus(status) {
    this.setFiles(status.files);
    this.inRebase(!!status.inRebase);
    this.inMerge(!!status.inMerge);
    // There are time where '.git/CHERRY_PICK_HEAD' file is created and no files are in conflicts.
    // in such cases we should ignore exception as no good way to resolve it.
    this.inCherry(!!status.inCherry && !!status.inConflict);

    if (this.inRebase()) {
      this.commitMessageTitle('Rebase conflict');
      this.commitMessageBody('Commit messages are not applicable!\n(╯°□°）╯︵ ┻━┻');
    } else if (this.inMerge() || this.inCherry()) {
      const lines = status.commitMessage.split('\n');
      if (!this.commitMessageTitle()) {
        this.commitMessageTitle(lines[0]);
        this.commitMessageBody(lines.slice(1).join('\n'));
      }
    }
  }

  setFiles(files) {
    const newFiles = [];
    for(let fileStatus of Object.values(files)) {
      let fileViewModel = this.filesByPath[fileStatus.fileName];
      if (!fileViewModel) {
        this.filesByPath[fileStatus.fileName] = fileViewModel = new FileViewModel(this, fileStatus.fileName, fileStatus.oldFileName, fileStatus.displayName);
      } else {
        // this is mainly for patching and it may not fire due to the fact that
        // '/commit' triggers working-tree-changed which triggers throttled refresh
        fileViewModel.diff().invalidateDiff();
      }
      fileViewModel.setState(fileStatus);
      newFiles.push(fileViewModel);
    }
    this.files(newFiles);
    programEvents.dispatch({ event: 'init-tooltip' });
  }

  toggleAmend() {
    if (!this.amend() && !this.commitMessageTitle()) {
      this.commitMessageTitle(this.HEAD().title);
      this.commitMessageBody(this.HEAD().body);
    } else if(this.amend()) {
      const isPrevDefaultMsg =
        this.commitMessageTitle() == this.HEAD().title &&
        this.commitMessageBody() == this.HEAD().body;
      if (isPrevDefaultMsg) {
        this.commitMessageTitle('');
        this.commitMessageBody('');
      }
    }
    this.amend(!this.amend());
  }

  toggleEmptyCommit() {
    this.commitMessageTitle('Empty commit');
    this.commitMessageBody();
    this.emptyCommit(true);
  }

  resetMessages() {
    this.commitMessageTitle('');
    this.commitMessageBody('');
    for (const key in this.filesByPath) {
      const element = this.filesByPath[key];
      element.diff().invalidateDiff();
      element.patchLineList.removeAll();
      element.isShowingDiffs(false);
      element.editState(element.editState() === 'patched' ? 'none' : element.editState());
    }
    this.amend(false);
    this.emptyCommit(false);
  }

  commit() {
    const files = this.files().filter(file => file.editState() !== 'none').map(file => ({
      name: file.name(),
      patchLineList: file.editState() === 'patched' ? file.patchLineList() : null
    }));
    let commitMessage = this.commitMessageTitle();
    if (this.commitMessageBody()) commitMessage += `\n\n${this.commitMessageBody()}`;

    this.server.postPromise('/commit', { path: this.repoPath(), message: commitMessage, files, amend: this.amend(), emptyCommit: this.emptyCommit() })
      .then(() => { this.resetMessages(); })
      .catch((e) => this.server.unhandledRejection(e));
  }

  commitnpush() {
    const files = this.files().filter(file => file.editState() !== 'none').map(file => ({
      name: file.name(),
      patchLineList: file.editState() === 'patched' ? file.patchLineList() : null
    }));
    let commitMessage = this.commitMessageTitle();
    if (this.commitMessageBody()) commitMessage += `\n\n${this.commitMessageBody()}`;

    this.server.postPromise('/commit', { path: this.repoPath(), message: commitMessage, files, amend: this.amend(), emptyCommit: this.emptyCommit() })
      .then(() => {
        this.resetMessages();
        return this.server.postPromise('/push', { path: this.repoPath(), remote: this.graph.currentRemote() });
      })
      .catch(err => {
        if (err.errorCode == 'non-fast-forward') {
          return components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' })
            .show()
            .closeThen(diag => {
              if (!diag.result()) return false;
              return this.server.postPromise('/push', { path: this.repoPath(), remote: this.graph.currentRemote(), force: true });
            }).closePromise;
        } else {
          this.server.unhandledRejection(err);
        }
      });
  }

  conflictResolution(apiPath) {
    let commitMessage = this.commitMessageTitle();
    if (this.commitMessageBody()) commitMessage += `\n\n${this.commitMessageBody()}`;
    this.server.postPromise(apiPath, { path: this.repoPath(), message: commitMessage })
      .catch((e) => this.server.unhandledRejection(e))
      .finally((err) => { this.resetMessages(); });
  }

  invalidateFilesDiffs() {
    this.files().forEach(file => {
      file.diff().invalidateDiff();
    });
  }

  cancelAmendEmpty() {
    this.resetMessages();
  }

  discardAllChanges() {
    components.create('yesnodialog', { title: 'Are you sure you want to discard all changes?', details: 'This operation cannot be undone.'})
      .show()
      .closeThen((diag) => {
        if (diag.result()) {
          this.server.postPromise('/discardchanges', { path: this.repoPath(), all: true })
            .catch((e) => this.server.unhandledRejection(e));
        }
      });
  }

  stashAll() {
    this.server.postPromise('/stashes', { path: this.repoPath(), message: this.commitMessageTitle() })
      .catch((e) => this.server.unhandledRejection(e));
  }

  toggleAllStages() {
    const allStageFlag = this.allStageFlag();
    for (const n in this.files()){
      this.files()[n].editState(allStageFlag ? 'staged' : 'none');
    }
  }

  onEnter(d, e) {
      if (e.keyCode === 13 && !this.commitValidationError()) {
        this.commit();
      }
      return true;
  }

  onAltEnter(d, e) {
      if (e.keyCode === 13 && e.altKey && !this.commitValidationError()) {
        this.commit();
      }
      return true;
  }
}

class FileViewModel {
  constructor(staging, name, oldName, displayName) {
    this.staging = staging;
    this.server = staging.server;
    this.editState = ko.observable('staged'); // staged, patched and none
    this.name = ko.observable(name);
    this.oldName = ko.observable(oldName);
    this.displayName = ko.observable(displayName);
    this.isNew = ko.observable(false);
    this.removed = ko.observable(false);
    this.conflict = ko.observable(false);
    this.renamed = ko.observable(false);
    this.isShowingDiffs = ko.observable(false);
    this.additions = ko.observable('');
    this.deletions = ko.observable('');
    this.modified = ko.computed(() => {
      // only show modfied whe not removed, not conflicted, not new, not renamed
      // and length of additions and deletions is 0.
      return !this.removed() && !this.conflict() && !this.isNew() &&
        this.additions().length === 0 && this.deletions().length === 0;
    });
    this.fileType = ko.observable('text');
    this.patchLineList = ko.observableArray();
    this.diff = ko.observable();
    this.isShowPatch = ko.computed(() => // if not new file
    // and if not merging
    // and if not rebasing
    // and if text file
    // and if diff is showing, display patch button
    !this.isNew() && !staging.inMerge() && !staging.inRebase() && this.fileType() === 'text' && this.isShowingDiffs());
    this.mergeTool = ko.computed(() => this.conflict() && mergeTool !== false);

    this.editState.subscribe(value => {
      if (value === 'none') {
        this.patchLineList.removeAll();
      } else if (value === 'patched') {
        if (this.diff().render) this.diff().render();
      }
    });
  }

  getSpecificDiff() {
    return components.create(!this.name() || `${this.fileType()}diff`, {
      filename: this.name(),
      oldFilename: this.oldName(),
      displayFilename: this.displayName(),
      repoPath: this.staging.repoPath,
      server: this.server,
      textDiffType: this.staging.textDiffType,
      whiteSpace: this.staging.whiteSpace,
      isShowingDiffs: this.isShowingDiffs,
      patchLineList: this.patchLineList,
      editState: this.editState,
      wordWrap: this.staging.wordWrap
    });
  }

  setState(state) {
    this.displayName(state.displayName);
    this.isNew(state.isNew);
    this.removed(state.removed);
    this.conflict(state.conflict);
    this.renamed(state.renamed);
    this.fileType(state.type);
    this.additions(state.additions != '-' ? `+${state.additions}` : '');
    this.deletions(state.deletions != '-' ? `-${state.deletions}` : '');
    if (this.diff()) {
      this.diff().invalidateDiff();
    } else {
      this.diff(this.getSpecificDiff());
    }
    if (this.diff().isNew) this.diff().isNew(state.isNew);
    if (this.diff().isRemoved) this.diff().isRemoved(state.removed);
  }

  toggleStaged() {
    if (this.editState() === 'none') {
      this.editState('staged');
    } else {
      this.editState('none');
    }
    this.patchLineList([]);
  }

  discardChanges() {
    if (ungit.config.disableDiscardWarning || new Date().getTime() - this.staging.mutedTime < ungit.config.disableDiscardMuteTime) {
      this.server.postPromise('/discardchanges', { path: this.staging.repoPath(), file: this.name() })
        .catch((e) => this.server.unhandledRejection(e));
    } else {
      components.create('yesnomutedialog', { title: 'Are you sure you want to discard these changes?', details: 'This operation cannot be undone.'})
        .show()
        .closeThen((diag) => {
          if (diag.result()) {
            this.server.postPromise('/discardchanges', { path: this.staging.repoPath(), file: this.name() })
              .catch((e) => this.server.unhandledRejection(e));
          }
          if (diag.result() === 'mute') this.staging.mutedTime = new Date().getTime();
        });
    }
  }

  ignoreFile() {
    this.server.postPromise('/ignorefile', { path: this.staging.repoPath(), file: this.name() })
      .catch(err => {
        if (err.errorCode == 'file-already-git-ignored') {
          // The file was already in the .gitignore, so force an update of the staging area (to hopefully clear away this file)
          programEvents.dispatch({ event: 'working-tree-changed' });
        } else {
          this.server.unhandledRejection(err);
        }
      });
  }

  resolveConflict() {
    this.server.postPromise('/resolveconflicts', { path: this.staging.repoPath(), files: [this.name()] })
      .catch((e) => this.server.unhandledRejection(e));
  }

  launchMergeTool() {
    this.server.postPromise('/launchmergetool', { path: this.staging.repoPath(), file: this.name(), tool: mergeTool })
      .catch((e) => this.server.unhandledRejection(e));
  }

  toggleDiffs() {
    this.isShowingDiffs(!this.isShowingDiffs());
  }

  patchClick() {
    if (!this.isShowingDiffs()) return;

    if (this.editState() === 'patched') {
      this.editState('staged');
    } else {
      this.editState('patched');
    }
  }
}

},{"bluebird":undefined,"knockout":"knockout","lodash":"lodash","octicons":undefined,"ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3N0YWdpbmcvc3RhZ2luZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY29uc3Qga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgcHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG5jb25zdCBvY3RpY29ucyA9IHJlcXVpcmUoJ29jdGljb25zJyk7XG5jb25zdCBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xuY29uc3QgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG5jb25zdCBmaWxlc1RvRGlzcGxheUluY3JtZW50QnkgPSA1MDtcbmNvbnN0IGZpbGVzVG9EaXNwbGF5TGltaXQgPSBmaWxlc1RvRGlzcGxheUluY3JtZW50Qnk7XG5jb25zdCBtZXJnZVRvb2wgPSB1bmdpdC5jb25maWcubWVyZ2VUb29sO1xuXG5jb21wb25lbnRzLnJlZ2lzdGVyKCdzdGFnaW5nJywgYXJncyA9PiBuZXcgU3RhZ2luZ1ZpZXdNb2RlbChhcmdzLnNlcnZlciwgYXJncy5yZXBvUGF0aCwgYXJncy5ncmFwaCkpO1xuXG5jbGFzcyBTdGFnaW5nVmlld01vZGVsIHtcbiAgY29uc3RydWN0b3Ioc2VydmVyLCByZXBvUGF0aCwgZ3JhcGgpIHtcbiAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuZmlsZXNCeVBhdGggPSB7fTtcbiAgICB0aGlzLmZpbGVzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gICAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGVDb3VudCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlQ291bnQodmFsdWUubGVuZ3RoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5ID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMud29yZFdyYXAgPSBjb21wb25lbnRzLmNyZWF0ZSgndGV4dGRpZmYud29yZHdyYXAnKTtcbiAgICB0aGlzLnRleHREaWZmVHlwZSA9IGNvbXBvbmVudHMuY3JlYXRlKCd0ZXh0ZGlmZi50eXBlJyk7XG4gICAgdGhpcy53aGl0ZVNwYWNlID0gY29tcG9uZW50cy5jcmVhdGUoJ3RleHRkaWZmLndoaXRlc3BhY2UnKTtcbiAgICB0aGlzLmluUmViYXNlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5pbk1lcmdlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5pbkNoZXJyeSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuY29uZmxpY3RUZXh0ID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaW5NZXJnZSgpKSB7XG4gICAgICAgIHRoaXMuY29uZmxpY3RDb250aW51ZSA9IHRoaXMuY29uZmxpY3RSZXNvbHV0aW9uLmJpbmQodGhpcywgJy9tZXJnZS9jb250aW51ZScpO1xuICAgICAgICB0aGlzLmNvbmZsaWN0QWJvcnQgPSB0aGlzLmNvbmZsaWN0UmVzb2x1dGlvbi5iaW5kKHRoaXMsICcvbWVyZ2UvYWJvcnQnKTtcbiAgICAgICAgcmV0dXJuICdNZXJnZSc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5SZWJhc2UoKSkge1xuICAgICAgICB0aGlzLmNvbmZsaWN0Q29udGludWUgPSB0aGlzLmNvbmZsaWN0UmVzb2x1dGlvbi5iaW5kKHRoaXMsICcvcmViYXNlL2NvbnRpbnVlJyk7XG4gICAgICAgIHRoaXMuY29uZmxpY3RBYm9ydCA9IHRoaXMuY29uZmxpY3RSZXNvbHV0aW9uLmJpbmQodGhpcywgJy9yZWJhc2UvYWJvcnQnKTtcbiAgICAgICAgcmV0dXJuICdSZWJhc2UnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmluQ2hlcnJ5KCkpIHtcbiAgICAgICAgdGhpcy5jb25mbGljdENvbnRpbnVlID0gdGhpcy5jb21taXQ7XG4gICAgICAgIHRoaXMuY29uZmxpY3RBYm9ydCA9IHRoaXMuZGlzY2FyZEFsbENoYW5nZXM7XG4gICAgICAgIHJldHVybiAnQ2hlcnJ5LXBpY2snO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25mbGljdENvbnRpbnVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmZsaWN0QWJvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5IRUFEID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuaXNTdGFnZVZhbGlkID0ga28uY29tcHV0ZWQoKCkgPT4gIXRoaXMuaW5SZWJhc2UoKSAmJiAhdGhpcy5pbk1lcmdlKCkgJiYgIXRoaXMuaW5DaGVycnkoKSk7XG4gICAgdGhpcy5uRmlsZXMgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLmZpbGVzKCkubGVuZ3RoKTtcbiAgICB0aGlzLm5TdGFnZWRGaWxlcyA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMuZmlsZXMoKS5maWx0ZXIoZiA9PiBmLmVkaXRTdGF0ZSgpID09PSAnc3RhZ2VkJykubGVuZ3RoKTtcbiAgICB0aGlzLmFsbFN0YWdlRmxhZyA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMubkZpbGVzKCkgIT09IHRoaXMublN0YWdlZEZpbGVzKCkpO1xuICAgIHRoaXMuc3RhdHMgPSBrby5jb21wdXRlZCgoKSA9PiBgJHt0aGlzLm5GaWxlcygpfSBmaWxlcywgJHt0aGlzLm5TdGFnZWRGaWxlcygpfSB0byBiZSBjb21taXRlZGApO1xuICAgIHRoaXMuYW1lbmQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmNhbkFtZW5kID0ga28uY29tcHV0ZWQoKCkgPT4gdGhpcy5IRUFEKCkgJiYgIXRoaXMuaW5SZWJhc2UoKSAmJiAhdGhpcy5pbk1lcmdlKCkgJiYgIXRoaXMuZW1wdHlDb21taXQoKSk7XG4gICAgdGhpcy5lbXB0eUNvbW1pdCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuY2FuRW1wdHlDb21taXQgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLkhFQUQoKSAmJiAhdGhpcy5pblJlYmFzZSgpICYmICF0aGlzLmluTWVyZ2UoKSk7XG4gICAgdGhpcy5jYW5TdGFzaEFsbCA9IGtvLmNvbXB1dGVkKCgpID0+ICF0aGlzLmFtZW5kKCkpO1xuICAgIHRoaXMuY2FuUHVzaCA9IGtvLmNvbXB1dGVkKCgpID0+ICEhdGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICAgIHRoaXMuc2hvd051eCA9IGtvLmNvbXB1dGVkKCgpID0+IHRoaXMuZmlsZXMoKS5sZW5ndGggPT0gMCAmJiAhdGhpcy5hbWVuZCgpICYmICF0aGlzLmluUmViYXNlKCkgJiYgIXRoaXMuZW1wdHlDb21taXQoKSk7XG4gICAgdGhpcy5zaG93Q2FuY2VsQnV0dG9uID0ga28uY29tcHV0ZWQoKCkgPT4gdGhpcy5hbWVuZCgpIHx8IHRoaXMuZW1wdHlDb21taXQoKSk7XG4gICAgdGhpcy5jb21taXRWYWxpZGF0aW9uRXJyb3IgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25mbGljdFRleHQoKSkge1xuICAgICAgICBpZiAodGhpcy5maWxlcygpLnNvbWUoKGZpbGUpID0+IGZpbGUuY29uZmxpY3QoKSkpIHJldHVybiAnRmlsZXMgaW4gY29uZmxpY3QnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmVtcHR5Q29tbWl0KCkgJiYgIXRoaXMuYW1lbmQoKSAmJiAhdGhpcy5maWxlcygpLnNvbWUoKGZpbGUpID0+IGZpbGUuZWRpdFN0YXRlKCkgPT09ICdzdGFnZWQnIHx8IGZpbGUuZWRpdFN0YXRlKCkgPT09ICdwYXRjaGVkJykpIHtcbiAgICAgICAgICByZXR1cm4gJ05vIGZpbGVzIHRvIGNvbW1pdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSgpKSB7XG4gICAgICAgICAgcmV0dXJuICdQcm92aWRlIGEgdGl0bGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dERpZmZUeXBlLnZhbHVlKCkgPT09ICdzaWRlYnlzaWRlZGlmZicpIHtcbiAgICAgICAgICBjb25zdCBwYXRjaEZpbGVzID0gdGhpcy5maWxlcygpLmZpbHRlcihmaWxlID0+IGZpbGUuZWRpdFN0YXRlKCkgPT09ICdwYXRjaGVkJyk7XG4gICAgICAgICAgaWYgKHBhdGNoRmlsZXMubGVuZ3RoID4gMCkgcmV0dXJuICdDYW5ub3QgcGF0Y2ggd2l0aCBzaWRlIGJ5IHNpZGUgdmlldy4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gICAgdGhpcy50b2dnbGVTZWxlY3RBbGxHbHlwaENsYXNzID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWxsU3RhZ2VGbGFnKCkpIHJldHVybiAnZ2x5cGhpY29uLXVuY2hlY2tlZCc7XG4gICAgICBlbHNlIHJldHVybiAnZ2x5cGhpY29uLWNoZWNrJztcbiAgICB9KTtcblxuICAgIHRoaXMucmVmcmVzaENvbnRlbnRUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMucmVmcmVzaENvbnRlbnQuYmluZCh0aGlzKSwgNDAwLCB7IHRyYWlsaW5nOiB0cnVlIH0pO1xuICAgIHRoaXMuaW52YWxpZGF0ZUZpbGVzRGlmZnNUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMuaW52YWxpZGF0ZUZpbGVzRGlmZnMuYmluZCh0aGlzKSwgNDAwLCB7IHRyYWlsaW5nOiB0cnVlIH0pO1xuICAgIHRoaXMucmVmcmVzaENvbnRlbnRUaHJvdHRsZWQoKTtcbiAgICB0aGlzLmxvYWRBbnl3YXkgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlhZ09wZW4gPSBmYWxzZTtcbiAgICB0aGlzLm11dGVkVGltZSA9IG51bGw7XG4gICAgdGhpcy5kaXNjYXJkQWxsSWNvbiA9IG9jdGljb25zLnRyYXNoY2FuLnRvU1ZHKHsgJ2hlaWdodCc6IDE1IH0pO1xuICAgIHRoaXMuc3Rhc2hJY29uID0gb2N0aWNvbnMucGluLnRvU1ZHKHsgJ2hlaWdodCc6IDE1IH0pO1xuICAgIHRoaXMuZGlzY2FyZEljb24gPSBvY3RpY29ucy54LnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pO1xuICAgIHRoaXMuaWdub3JlSWNvbiA9IG9jdGljb25zLnNraXAudG9TVkcoeyAnaGVpZ2h0JzogMTggfSk7XG4gIH1cblxuICB1cGRhdGVOb2RlKHBhcmVudEVsZW1lbnQpIHtcbiAgICBrby5yZW5kZXJUZW1wbGF0ZSgnc3RhZ2luZycsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIG9uUHJvZ3JhbUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmV2ZW50ID09ICdyZXF1ZXN0LWFwcC1jb250ZW50LXJlZnJlc2gnKSB7XG4gICAgICB0aGlzLnJlZnJlc2hDb250ZW50KCk7XG4gICAgICB0aGlzLmludmFsaWRhdGVGaWxlc0RpZmZzKCk7XG4gICAgfVxuICAgIGlmIChldmVudC5ldmVudCA9PSAnd29ya2luZy10cmVlLWNoYW5nZWQnKSB7XG4gICAgICB0aGlzLnJlZnJlc2hDb250ZW50VGhyb3R0bGVkKCk7XG4gICAgICB0aGlzLmludmFsaWRhdGVGaWxlc0RpZmZzVGhyb3R0bGVkKCk7XG4gICAgfVxuICB9XG5cbiAgcmVmcmVzaENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHByb21pc2UuYWxsKFt0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvaGVhZCcsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCBsaW1pdDogMSB9KVxuICAgICAgICAudGhlbihsb2cgPT4ge1xuICAgICAgICAgIGlmIChsb2cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBsb2dbMF0ubWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB0aGlzLkhFQUQoe3RpdGxlOiBhcnJheVswXSwgYm9keTogYXJyYXkuc2xpY2UoMikuam9pbignXFxuJyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB0aGlzLkhFQUQobnVsbCk7XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgIT0gJ211c3QtYmUtaW4td29ya2luZy10cmVlJyAmJiBlcnIuZXJyb3JDb2RlICE9ICduby1zdWNoLXBhdGgnKSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL3N0YXR1cycsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCBmaWxlTGltaXQ6IGZpbGVzVG9EaXNwbGF5TGltaXQgfSlcbiAgICAgICAgLnRoZW4oc3RhdHVzID0+IHtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3RhdHVzLmZpbGVzKS5sZW5ndGggPiBmaWxlc1RvRGlzcGxheUxpbWl0ICYmICF0aGlzLmxvYWRBbnl3YXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlhZ09wZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0RpYWdPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRzLmNyZWF0ZSgndG9vbWFueWZpbGVzZGlhbG9ndmlld21vZGVsJywgeyB0aXRsZTogJ1RvbyBtYW55IHVuc3RhZ2VkIGZpbGVzJywgZGV0YWlsczogJ0l0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBjb21tYW5kIGxpbmUgYXMgdW5naXQgbWF5IGJlIHRvbyBzbG93Lid9KVxuICAgICAgICAgICAgICAuc2hvdygpXG4gICAgICAgICAgICAgIC5jbG9zZVRoZW4oZGlhZyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RpYWdPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubG9hZEFueXdheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvYWRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnLyMvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgIT0gJ211c3QtYmUtaW4td29ya2luZy10cmVlJyAmJiBlcnIuZXJyb3JDb2RlICE9ICduby1zdWNoLXBhdGgnKSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXSk7XG4gIH1cblxuICBsb2FkU3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMuc2V0RmlsZXMoc3RhdHVzLmZpbGVzKTtcbiAgICB0aGlzLmluUmViYXNlKCEhc3RhdHVzLmluUmViYXNlKTtcbiAgICB0aGlzLmluTWVyZ2UoISFzdGF0dXMuaW5NZXJnZSk7XG4gICAgLy8gVGhlcmUgYXJlIHRpbWUgd2hlcmUgJy5naXQvQ0hFUlJZX1BJQ0tfSEVBRCcgZmlsZSBpcyBjcmVhdGVkIGFuZCBubyBmaWxlcyBhcmUgaW4gY29uZmxpY3RzLlxuICAgIC8vIGluIHN1Y2ggY2FzZXMgd2Ugc2hvdWxkIGlnbm9yZSBleGNlcHRpb24gYXMgbm8gZ29vZCB3YXkgdG8gcmVzb2x2ZSBpdC5cbiAgICB0aGlzLmluQ2hlcnJ5KCEhc3RhdHVzLmluQ2hlcnJ5ICYmICEhc3RhdHVzLmluQ29uZmxpY3QpO1xuXG4gICAgaWYgKHRoaXMuaW5SZWJhc2UoKSkge1xuICAgICAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoJ1JlYmFzZSBjb25mbGljdCcpO1xuICAgICAgdGhpcy5jb21taXRNZXNzYWdlQm9keSgnQ29tbWl0IG1lc3NhZ2VzIGFyZSBub3QgYXBwbGljYWJsZSFcXG4o4pWvwrDilqHCsO+8ieKVr++4tSDilLvilIHilLsnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5NZXJnZSgpIHx8IHRoaXMuaW5DaGVycnkoKSkge1xuICAgICAgY29uc3QgbGluZXMgPSBzdGF0dXMuY29tbWl0TWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgICBpZiAoIXRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCkpIHtcbiAgICAgICAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUobGluZXNbMF0pO1xuICAgICAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KGxpbmVzLnNsaWNlKDEpLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRGaWxlcyhmaWxlcykge1xuICAgIGNvbnN0IG5ld0ZpbGVzID0gW107XG4gICAgZm9yKGxldCBmaWxlU3RhdHVzIG9mIE9iamVjdC52YWx1ZXMoZmlsZXMpKSB7XG4gICAgICBsZXQgZmlsZVZpZXdNb2RlbCA9IHRoaXMuZmlsZXNCeVBhdGhbZmlsZVN0YXR1cy5maWxlTmFtZV07XG4gICAgICBpZiAoIWZpbGVWaWV3TW9kZWwpIHtcbiAgICAgICAgdGhpcy5maWxlc0J5UGF0aFtmaWxlU3RhdHVzLmZpbGVOYW1lXSA9IGZpbGVWaWV3TW9kZWwgPSBuZXcgRmlsZVZpZXdNb2RlbCh0aGlzLCBmaWxlU3RhdHVzLmZpbGVOYW1lLCBmaWxlU3RhdHVzLm9sZEZpbGVOYW1lLCBmaWxlU3RhdHVzLmRpc3BsYXlOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbWFpbmx5IGZvciBwYXRjaGluZyBhbmQgaXQgbWF5IG5vdCBmaXJlIGR1ZSB0byB0aGUgZmFjdCB0aGF0XG4gICAgICAgIC8vICcvY29tbWl0JyB0cmlnZ2VycyB3b3JraW5nLXRyZWUtY2hhbmdlZCB3aGljaCB0cmlnZ2VycyB0aHJvdHRsZWQgcmVmcmVzaFxuICAgICAgICBmaWxlVmlld01vZGVsLmRpZmYoKS5pbnZhbGlkYXRlRGlmZigpO1xuICAgICAgfVxuICAgICAgZmlsZVZpZXdNb2RlbC5zZXRTdGF0ZShmaWxlU3RhdHVzKTtcbiAgICAgIG5ld0ZpbGVzLnB1c2goZmlsZVZpZXdNb2RlbCk7XG4gICAgfVxuICAgIHRoaXMuZmlsZXMobmV3RmlsZXMpO1xuICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2luaXQtdG9vbHRpcCcgfSk7XG4gIH1cblxuICB0b2dnbGVBbWVuZCgpIHtcbiAgICBpZiAoIXRoaXMuYW1lbmQoKSAmJiAhdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKSkge1xuICAgICAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUodGhpcy5IRUFEKCkudGl0bGUpO1xuICAgICAgdGhpcy5jb21taXRNZXNzYWdlQm9keSh0aGlzLkhFQUQoKS5ib2R5KTtcbiAgICB9IGVsc2UgaWYodGhpcy5hbWVuZCgpKSB7XG4gICAgICBjb25zdCBpc1ByZXZEZWZhdWx0TXNnID1cbiAgICAgICAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKSA9PSB0aGlzLkhFQUQoKS50aXRsZSAmJlxuICAgICAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCkgPT0gdGhpcy5IRUFEKCkuYm9keTtcbiAgICAgIGlmIChpc1ByZXZEZWZhdWx0TXNnKSB7XG4gICAgICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCcnKTtcbiAgICAgICAgdGhpcy5jb21taXRNZXNzYWdlQm9keSgnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW1lbmQoIXRoaXMuYW1lbmQoKSk7XG4gIH1cblxuICB0b2dnbGVFbXB0eUNvbW1pdCgpIHtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSgnRW1wdHkgY29tbWl0Jyk7XG4gICAgdGhpcy5jb21taXRNZXNzYWdlQm9keSgpO1xuICAgIHRoaXMuZW1wdHlDb21taXQodHJ1ZSk7XG4gIH1cblxuICByZXNldE1lc3NhZ2VzKCkge1xuICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCcnKTtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCcnKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmZpbGVzQnlQYXRoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5maWxlc0J5UGF0aFtrZXldO1xuICAgICAgZWxlbWVudC5kaWZmKCkuaW52YWxpZGF0ZURpZmYoKTtcbiAgICAgIGVsZW1lbnQucGF0Y2hMaW5lTGlzdC5yZW1vdmVBbGwoKTtcbiAgICAgIGVsZW1lbnQuaXNTaG93aW5nRGlmZnMoZmFsc2UpO1xuICAgICAgZWxlbWVudC5lZGl0U3RhdGUoZWxlbWVudC5lZGl0U3RhdGUoKSA9PT0gJ3BhdGNoZWQnID8gJ25vbmUnIDogZWxlbWVudC5lZGl0U3RhdGUoKSk7XG4gICAgfVxuICAgIHRoaXMuYW1lbmQoZmFsc2UpO1xuICAgIHRoaXMuZW1wdHlDb21taXQoZmFsc2UpO1xuICB9XG5cbiAgY29tbWl0KCkge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5maWxlcygpLmZpbHRlcihmaWxlID0+IGZpbGUuZWRpdFN0YXRlKCkgIT09ICdub25lJykubWFwKGZpbGUgPT4gKHtcbiAgICAgIG5hbWU6IGZpbGUubmFtZSgpLFxuICAgICAgcGF0Y2hMaW5lTGlzdDogZmlsZS5lZGl0U3RhdGUoKSA9PT0gJ3BhdGNoZWQnID8gZmlsZS5wYXRjaExpbmVMaXN0KCkgOiBudWxsXG4gICAgfSkpO1xuICAgIGxldCBjb21taXRNZXNzYWdlID0gdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKTtcbiAgICBpZiAodGhpcy5jb21taXRNZXNzYWdlQm9keSgpKSBjb21taXRNZXNzYWdlICs9IGBcXG5cXG4ke3RoaXMuY29tbWl0TWVzc2FnZUJvZHkoKX1gO1xuXG4gICAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9jb21taXQnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgbWVzc2FnZTogY29tbWl0TWVzc2FnZSwgZmlsZXMsIGFtZW5kOiB0aGlzLmFtZW5kKCksIGVtcHR5Q29tbWl0OiB0aGlzLmVtcHR5Q29tbWl0KCkgfSlcbiAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5yZXNldE1lc3NhZ2VzKCk7IH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSk7XG4gIH1cblxuICBjb21taXRucHVzaCgpIHtcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZmlsZXMoKS5maWx0ZXIoZmlsZSA9PiBmaWxlLmVkaXRTdGF0ZSgpICE9PSAnbm9uZScpLm1hcChmaWxlID0+ICh7XG4gICAgICBuYW1lOiBmaWxlLm5hbWUoKSxcbiAgICAgIHBhdGNoTGluZUxpc3Q6IGZpbGUuZWRpdFN0YXRlKCkgPT09ICdwYXRjaGVkJyA/IGZpbGUucGF0Y2hMaW5lTGlzdCgpIDogbnVsbFxuICAgIH0pKTtcbiAgICBsZXQgY29tbWl0TWVzc2FnZSA9IHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCk7XG4gICAgaWYgKHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKSkgY29tbWl0TWVzc2FnZSArPSBgXFxuXFxuJHt0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCl9YDtcblxuICAgIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvY29tbWl0JywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIG1lc3NhZ2U6IGNvbW1pdE1lc3NhZ2UsIGZpbGVzLCBhbWVuZDogdGhpcy5hbWVuZCgpLCBlbXB0eUNvbW1pdDogdGhpcy5lbXB0eUNvbW1pdCgpIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzZXRNZXNzYWdlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9wdXNoJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIHJlbW90ZTogdGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIuZXJyb3JDb2RlID09ICdub24tZmFzdC1mb3J3YXJkJykge1xuICAgICAgICAgIHJldHVybiBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnRm9yY2UgcHVzaD8nLCBkZXRhaWxzOiAnVGhlIHJlbW90ZSBicmFuY2ggY2FuXFwndCBiZSBmYXN0LWZvcndhcmRlZC4nIH0pXG4gICAgICAgICAgICAuc2hvdygpXG4gICAgICAgICAgICAuY2xvc2VUaGVuKGRpYWcgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWRpYWcucmVzdWx0KCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcHVzaCcsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCByZW1vdGU6IHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pLmNsb3NlUHJvbWlzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBjb25mbGljdFJlc29sdXRpb24oYXBpUGF0aCkge1xuICAgIGxldCBjb21taXRNZXNzYWdlID0gdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKTtcbiAgICBpZiAodGhpcy5jb21taXRNZXNzYWdlQm9keSgpKSBjb21taXRNZXNzYWdlICs9IGBcXG5cXG4ke3RoaXMuY29tbWl0TWVzc2FnZUJvZHkoKX1gO1xuICAgIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKGFwaVBhdGgsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCBtZXNzYWdlOiBjb21taXRNZXNzYWdlIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSlcbiAgICAgIC5maW5hbGx5KChlcnIpID0+IHsgdGhpcy5yZXNldE1lc3NhZ2VzKCk7IH0pO1xuICB9XG5cbiAgaW52YWxpZGF0ZUZpbGVzRGlmZnMoKSB7XG4gICAgdGhpcy5maWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBmaWxlLmRpZmYoKS5pbnZhbGlkYXRlRGlmZigpO1xuICAgIH0pO1xuICB9XG5cbiAgY2FuY2VsQW1lbmRFbXB0eSgpIHtcbiAgICB0aGlzLnJlc2V0TWVzc2FnZXMoKTtcbiAgfVxuXG4gIGRpc2NhcmRBbGxDaGFuZ2VzKCkge1xuICAgIGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub2RpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGlzY2FyZCBhbGwgY2hhbmdlcz8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nfSlcbiAgICAgIC5zaG93KClcbiAgICAgIC5jbG9zZVRoZW4oKGRpYWcpID0+IHtcbiAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgICB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL2Rpc2NhcmRjaGFuZ2VzJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIGFsbDogdHJ1ZSB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHN0YXNoQWxsKCkge1xuICAgIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvc3Rhc2hlcycsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCBtZXNzYWdlOiB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSgpIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSk7XG4gIH1cblxuICB0b2dnbGVBbGxTdGFnZXMoKSB7XG4gICAgY29uc3QgYWxsU3RhZ2VGbGFnID0gdGhpcy5hbGxTdGFnZUZsYWcoKTtcbiAgICBmb3IgKGNvbnN0IG4gaW4gdGhpcy5maWxlcygpKXtcbiAgICAgIHRoaXMuZmlsZXMoKVtuXS5lZGl0U3RhdGUoYWxsU3RhZ2VGbGFnID8gJ3N0YWdlZCcgOiAnbm9uZScpO1xuICAgIH1cbiAgfVxuXG4gIG9uRW50ZXIoZCwgZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgIXRoaXMuY29tbWl0VmFsaWRhdGlvbkVycm9yKCkpIHtcbiAgICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb25BbHRFbnRlcihkLCBlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMyAmJiBlLmFsdEtleSAmJiAhdGhpcy5jb21taXRWYWxpZGF0aW9uRXJyb3IoKSkge1xuICAgICAgICB0aGlzLmNvbW1pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuY2xhc3MgRmlsZVZpZXdNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKHN0YWdpbmcsIG5hbWUsIG9sZE5hbWUsIGRpc3BsYXlOYW1lKSB7XG4gICAgdGhpcy5zdGFnaW5nID0gc3RhZ2luZztcbiAgICB0aGlzLnNlcnZlciA9IHN0YWdpbmcuc2VydmVyO1xuICAgIHRoaXMuZWRpdFN0YXRlID0ga28ub2JzZXJ2YWJsZSgnc3RhZ2VkJyk7IC8vIHN0YWdlZCwgcGF0Y2hlZCBhbmQgbm9uZVxuICAgIHRoaXMubmFtZSA9IGtvLm9ic2VydmFibGUobmFtZSk7XG4gICAgdGhpcy5vbGROYW1lID0ga28ub2JzZXJ2YWJsZShvbGROYW1lKTtcbiAgICB0aGlzLmRpc3BsYXlOYW1lID0ga28ub2JzZXJ2YWJsZShkaXNwbGF5TmFtZSk7XG4gICAgdGhpcy5pc05ldyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMucmVtb3ZlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuY29uZmxpY3QgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLnJlbmFtZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmlzU2hvd2luZ0RpZmZzID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5hZGRpdGlvbnMgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICB0aGlzLmRlbGV0aW9ucyA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIHRoaXMubW9kaWZpZWQgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICAvLyBvbmx5IHNob3cgbW9kZmllZCB3aGUgbm90IHJlbW92ZWQsIG5vdCBjb25mbGljdGVkLCBub3QgbmV3LCBub3QgcmVuYW1lZFxuICAgICAgLy8gYW5kIGxlbmd0aCBvZiBhZGRpdGlvbnMgYW5kIGRlbGV0aW9ucyBpcyAwLlxuICAgICAgcmV0dXJuICF0aGlzLnJlbW92ZWQoKSAmJiAhdGhpcy5jb25mbGljdCgpICYmICF0aGlzLmlzTmV3KCkgJiZcbiAgICAgICAgdGhpcy5hZGRpdGlvbnMoKS5sZW5ndGggPT09IDAgJiYgdGhpcy5kZWxldGlvbnMoKS5sZW5ndGggPT09IDA7XG4gICAgfSk7XG4gICAgdGhpcy5maWxlVHlwZSA9IGtvLm9ic2VydmFibGUoJ3RleHQnKTtcbiAgICB0aGlzLnBhdGNoTGluZUxpc3QgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB0aGlzLmRpZmYgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5pc1Nob3dQYXRjaCA9IGtvLmNvbXB1dGVkKCgpID0+IC8vIGlmIG5vdCBuZXcgZmlsZVxuICAgIC8vIGFuZCBpZiBub3QgbWVyZ2luZ1xuICAgIC8vIGFuZCBpZiBub3QgcmViYXNpbmdcbiAgICAvLyBhbmQgaWYgdGV4dCBmaWxlXG4gICAgLy8gYW5kIGlmIGRpZmYgaXMgc2hvd2luZywgZGlzcGxheSBwYXRjaCBidXR0b25cbiAgICAhdGhpcy5pc05ldygpICYmICFzdGFnaW5nLmluTWVyZ2UoKSAmJiAhc3RhZ2luZy5pblJlYmFzZSgpICYmIHRoaXMuZmlsZVR5cGUoKSA9PT0gJ3RleHQnICYmIHRoaXMuaXNTaG93aW5nRGlmZnMoKSk7XG4gICAgdGhpcy5tZXJnZVRvb2wgPSBrby5jb21wdXRlZCgoKSA9PiB0aGlzLmNvbmZsaWN0KCkgJiYgbWVyZ2VUb29sICE9PSBmYWxzZSk7XG5cbiAgICB0aGlzLmVkaXRTdGF0ZS5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5wYXRjaExpbmVMaXN0LnJlbW92ZUFsbCgpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3BhdGNoZWQnKSB7XG4gICAgICAgIGlmICh0aGlzLmRpZmYoKS5yZW5kZXIpIHRoaXMuZGlmZigpLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0U3BlY2lmaWNEaWZmKCkge1xuICAgIHJldHVybiBjb21wb25lbnRzLmNyZWF0ZSghdGhpcy5uYW1lKCkgfHwgYCR7dGhpcy5maWxlVHlwZSgpfWRpZmZgLCB7XG4gICAgICBmaWxlbmFtZTogdGhpcy5uYW1lKCksXG4gICAgICBvbGRGaWxlbmFtZTogdGhpcy5vbGROYW1lKCksXG4gICAgICBkaXNwbGF5RmlsZW5hbWU6IHRoaXMuZGlzcGxheU5hbWUoKSxcbiAgICAgIHJlcG9QYXRoOiB0aGlzLnN0YWdpbmcucmVwb1BhdGgsXG4gICAgICBzZXJ2ZXI6IHRoaXMuc2VydmVyLFxuICAgICAgdGV4dERpZmZUeXBlOiB0aGlzLnN0YWdpbmcudGV4dERpZmZUeXBlLFxuICAgICAgd2hpdGVTcGFjZTogdGhpcy5zdGFnaW5nLndoaXRlU3BhY2UsXG4gICAgICBpc1Nob3dpbmdEaWZmczogdGhpcy5pc1Nob3dpbmdEaWZmcyxcbiAgICAgIHBhdGNoTGluZUxpc3Q6IHRoaXMucGF0Y2hMaW5lTGlzdCxcbiAgICAgIGVkaXRTdGF0ZTogdGhpcy5lZGl0U3RhdGUsXG4gICAgICB3b3JkV3JhcDogdGhpcy5zdGFnaW5nLndvcmRXcmFwXG4gICAgfSk7XG4gIH1cblxuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuZGlzcGxheU5hbWUoc3RhdGUuZGlzcGxheU5hbWUpO1xuICAgIHRoaXMuaXNOZXcoc3RhdGUuaXNOZXcpO1xuICAgIHRoaXMucmVtb3ZlZChzdGF0ZS5yZW1vdmVkKTtcbiAgICB0aGlzLmNvbmZsaWN0KHN0YXRlLmNvbmZsaWN0KTtcbiAgICB0aGlzLnJlbmFtZWQoc3RhdGUucmVuYW1lZCk7XG4gICAgdGhpcy5maWxlVHlwZShzdGF0ZS50eXBlKTtcbiAgICB0aGlzLmFkZGl0aW9ucyhzdGF0ZS5hZGRpdGlvbnMgIT0gJy0nID8gYCske3N0YXRlLmFkZGl0aW9uc31gIDogJycpO1xuICAgIHRoaXMuZGVsZXRpb25zKHN0YXRlLmRlbGV0aW9ucyAhPSAnLScgPyBgLSR7c3RhdGUuZGVsZXRpb25zfWAgOiAnJyk7XG4gICAgaWYgKHRoaXMuZGlmZigpKSB7XG4gICAgICB0aGlzLmRpZmYoKS5pbnZhbGlkYXRlRGlmZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpZmYodGhpcy5nZXRTcGVjaWZpY0RpZmYoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpZmYoKS5pc05ldykgdGhpcy5kaWZmKCkuaXNOZXcoc3RhdGUuaXNOZXcpO1xuICAgIGlmICh0aGlzLmRpZmYoKS5pc1JlbW92ZWQpIHRoaXMuZGlmZigpLmlzUmVtb3ZlZChzdGF0ZS5yZW1vdmVkKTtcbiAgfVxuXG4gIHRvZ2dsZVN0YWdlZCgpIHtcbiAgICBpZiAodGhpcy5lZGl0U3RhdGUoKSA9PT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLmVkaXRTdGF0ZSgnc3RhZ2VkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWRpdFN0YXRlKCdub25lJyk7XG4gICAgfVxuICAgIHRoaXMucGF0Y2hMaW5lTGlzdChbXSk7XG4gIH1cblxuICBkaXNjYXJkQ2hhbmdlcygpIHtcbiAgICBpZiAodW5naXQuY29uZmlnLmRpc2FibGVEaXNjYXJkV2FybmluZyB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuc3RhZ2luZy5tdXRlZFRpbWUgPCB1bmdpdC5jb25maWcuZGlzYWJsZURpc2NhcmRNdXRlVGltZSkge1xuICAgICAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9kaXNjYXJkY2hhbmdlcycsIHsgcGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoKCksIGZpbGU6IHRoaXMubmFtZSgpIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5jcmVhdGUoJ3llc25vbXV0ZWRpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGlzY2FyZCB0aGVzZSBjaGFuZ2VzPycsIGRldGFpbHM6ICdUaGlzIG9wZXJhdGlvbiBjYW5ub3QgYmUgdW5kb25lLid9KVxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5jbG9zZVRoZW4oKGRpYWcpID0+IHtcbiAgICAgICAgICBpZiAoZGlhZy5yZXN1bHQoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9kaXNjYXJkY2hhbmdlcycsIHsgcGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoKCksIGZpbGU6IHRoaXMubmFtZSgpIH0pXG4gICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkgPT09ICdtdXRlJykgdGhpcy5zdGFnaW5nLm11dGVkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZ25vcmVGaWxlKCkge1xuICAgIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvaWdub3JlZmlsZScsIHsgcGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoKCksIGZpbGU6IHRoaXMubmFtZSgpIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgPT0gJ2ZpbGUtYWxyZWFkeS1naXQtaWdub3JlZCcpIHtcbiAgICAgICAgICAvLyBUaGUgZmlsZSB3YXMgYWxyZWFkeSBpbiB0aGUgLmdpdGlnbm9yZSwgc28gZm9yY2UgYW4gdXBkYXRlIG9mIHRoZSBzdGFnaW5nIGFyZWEgKHRvIGhvcGVmdWxseSBjbGVhciBhd2F5IHRoaXMgZmlsZSlcbiAgICAgICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICd3b3JraW5nLXRyZWUtY2hhbmdlZCcgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgcmVzb2x2ZUNvbmZsaWN0KCkge1xuICAgIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcmVzb2x2ZWNvbmZsaWN0cycsIHsgcGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoKCksIGZpbGVzOiBbdGhpcy5uYW1lKCldIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSk7XG4gIH1cblxuICBsYXVuY2hNZXJnZVRvb2woKSB7XG4gICAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9sYXVuY2htZXJnZXRvb2wnLCB7IHBhdGg6IHRoaXMuc3RhZ2luZy5yZXBvUGF0aCgpLCBmaWxlOiB0aGlzLm5hbWUoKSwgdG9vbDogbWVyZ2VUb29sIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSk7XG4gIH1cblxuICB0b2dnbGVEaWZmcygpIHtcbiAgICB0aGlzLmlzU2hvd2luZ0RpZmZzKCF0aGlzLmlzU2hvd2luZ0RpZmZzKCkpO1xuICB9XG5cbiAgcGF0Y2hDbGljaygpIHtcbiAgICBpZiAoIXRoaXMuaXNTaG93aW5nRGlmZnMoKSkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuZWRpdFN0YXRlKCkgPT09ICdwYXRjaGVkJykge1xuICAgICAgdGhpcy5lZGl0U3RhdGUoJ3N0YWdlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVkaXRTdGF0ZSgncGF0Y2hlZCcpO1xuICAgIH1cbiAgfVxufVxuIl19
