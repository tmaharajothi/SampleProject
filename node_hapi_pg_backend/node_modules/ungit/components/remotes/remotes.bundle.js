(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const ko = require('knockout');
const _ = require('lodash');
const promise = require('bluebird');
const octicons = require('octicons');
const components = require('ungit-components');
const programEvents = require('ungit-program-events');

components.register('remotes', args => new RemotesViewModel(args.server, args.repoPath));

class RemotesViewModel {
  constructor(server, repoPath) {
    this.repoPath = repoPath;
    this.server = server;
    this.remotes = ko.observable([]);
    this.currentRemote = ko.observable(null);
    this.currentRemote.subscribe(value => {
      programEvents.dispatch({ event: 'current-remote-changed', newRemote: value });
    });
    this.fetchLabel = ko.computed(() => {
      if (this.currentRemote()) return `Fetch from ${this.currentRemote()}`;
      else return 'No remotes specified';
    });
    this.remotesIcon = octicons['cloud-download'].toSVG({ 'height': 18 });
    this.closeIcon = octicons.x.toSVG({ 'height': 18 });

    this.fetchEnabled = ko.computed(() => this.remotes().length > 0);

    this.shouldAutoFetch = ungit.config.autoFetch;
    this.updateRemotes();
    this.isFetching = false;
    this.fetchDebounced = _.debounce(() => this.fetch({ tags: true }), 500);
  }

  updateNode(parentElement) {
    ko.renderTemplate('remotes', this, {}, parentElement);
  }

  clickFetch() { this.fetch({ nodes: true, tags: true }); }

  onProgramEvent(event) {
    if (event.event === 'working-tree-changed' || event.event === 'request-app-content-refresh' ||
      event.event === 'request-fetch-tags' || event.event === 'git-directory-changed') {
      this.fetchDebounced();
    }
  }

  fetch(options) {
    if (this.isFetching || !this.currentRemote()) return;

    this.isFetching = true;
    const tagPromise = options.tags ? this.server.getPromise('/remote/tags', { path: this.repoPath(), remote: this.currentRemote() }) : null;
    const fetchPromise = options.nodes ? this.server.postPromise('/fetch', { path: this.repoPath(), remote: this.currentRemote() }) : null;
    return promise.props({tag: tagPromise, fetch: fetchPromise})
      .then((result) => {
        if (options.tags) {
          programEvents.dispatch({ event: 'remote-tags-update', tags: result.tag });
        }
        if (!this.server.isInternetConnected) {
          this.server.isInternetConnected = true;
        }
      }).catch((err) => {
      let errorMessage;
      let stdout;
      let stderr;
      try {
        errorMessage = `Ungit has failed to fetch a remote.  ${err.res.body.error}`;
        stdout = err.res.body.stdout;
        stderr = err.res.body.stderr;
      } catch (e) { errorMessage = ''; }

      if (errorMessage.includes('Could not resolve host')) {
        if (this.server.isInternetConnected) {
          this.server.isInternetConnected = false;
          errorMessage = 'Could not resolve host. This usually means you are disconnected from internet and no longer push or fetch from remote. However, Ungit will be functional for local git operations.';
          stdout = '';
          stderr = '';
        } else {
          // Message is already seen, just return
          return;
        }
      }

      programEvents.dispatch({ event: 'git-error', data: {
        isWarning: true,
        command: err.res.body.command,
        error: err.res.body.error,
        stdout,
        stderr,
        repoPath: err.res.body.workingDirectory
      } });
    }).finally(() => { this.isFetching = false; });
  }

  updateRemotes() {
    return this.server.getPromise('/remotes', { path: this.repoPath() })
      .then(remotes => {
        remotes = remotes.map(remote => ({
          name: remote,
          changeRemote: () => { this.currentRemote(remote); }
        }));
        this.remotes(remotes);
        if (!this.currentRemote() && remotes.length > 0) {
          if (_.find(remotes, { 'name': 'origin' })) {// default to origin if it exists
            this.currentRemote('origin');
          } else {// otherwise take the first one
            this.currentRemote(remotes[0].name);
          }

          if (this.shouldAutoFetch) {
            this.shouldAutoFetch = false;
            return this.fetch({ nodes: true, tags: true });
          }
        }
      }).catch(err => {
        if (err.errorCode != 'not-a-repository') this.server.unhandledRejection(err);
      });
  }

  showAddRemoteDialog() {
    components.create('addremotedialog')
      .show()
      .closeThen((diag) => {
        if(diag.isSubmitted()) {
          return this.server.postPromise(`/remotes/${encodeURIComponent(diag.name())}`, { path: this.repoPath(), url: diag.url() })
            .then(() => { this.updateRemotes(); })
            .catch((e) => this.server.unhandledRejection(e));
        }
      });
  }

  remoteRemove(remote) {
    components.create('yesnodialog', { title: 'Are you sure?', details: `Deleting ${remote.name} remote cannot be undone with ungit.`})
      .show()
      .closeThen((diag) => {
        if (diag.result()) {
          return this.server.delPromise(`/remotes/${remote.name}`, { path: this.repoPath() })
            .then(() => { this.updateRemotes(); })
            .catch((e) => this.server.unhandledRejection(e));
        }
      });
  }
}

},{"bluebird":undefined,"knockout":"knockout","lodash":"lodash","octicons":undefined,"ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3JlbW90ZXMvcmVtb3Rlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJjb25zdCBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBwcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbmNvbnN0IG9jdGljb25zID0gcmVxdWlyZSgnb2N0aWNvbnMnKTtcbmNvbnN0IGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG5jb25zdCBwcm9ncmFtRXZlbnRzID0gcmVxdWlyZSgndW5naXQtcHJvZ3JhbS1ldmVudHMnKTtcblxuY29tcG9uZW50cy5yZWdpc3RlcigncmVtb3RlcycsIGFyZ3MgPT4gbmV3IFJlbW90ZXNWaWV3TW9kZWwoYXJncy5zZXJ2ZXIsIGFyZ3MucmVwb1BhdGgpKTtcblxuY2xhc3MgUmVtb3Rlc1ZpZXdNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKHNlcnZlciwgcmVwb1BhdGgpIHtcbiAgICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgdGhpcy5yZW1vdGVzID0ga28ub2JzZXJ2YWJsZShbXSk7XG4gICAgdGhpcy5jdXJyZW50UmVtb3RlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICB0aGlzLmN1cnJlbnRSZW1vdGUuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2N1cnJlbnQtcmVtb3RlLWNoYW5nZWQnLCBuZXdSZW1vdGU6IHZhbHVlIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZmV0Y2hMYWJlbCA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSZW1vdGUoKSkgcmV0dXJuIGBGZXRjaCBmcm9tICR7dGhpcy5jdXJyZW50UmVtb3RlKCl9YDtcbiAgICAgIGVsc2UgcmV0dXJuICdObyByZW1vdGVzIHNwZWNpZmllZCc7XG4gICAgfSk7XG4gICAgdGhpcy5yZW1vdGVzSWNvbiA9IG9jdGljb25zWydjbG91ZC1kb3dubG9hZCddLnRvU1ZHKHsgJ2hlaWdodCc6IDE4IH0pO1xuICAgIHRoaXMuY2xvc2VJY29uID0gb2N0aWNvbnMueC50b1NWRyh7ICdoZWlnaHQnOiAxOCB9KTtcblxuICAgIHRoaXMuZmV0Y2hFbmFibGVkID0ga28uY29tcHV0ZWQoKCkgPT4gdGhpcy5yZW1vdGVzKCkubGVuZ3RoID4gMCk7XG5cbiAgICB0aGlzLnNob3VsZEF1dG9GZXRjaCA9IHVuZ2l0LmNvbmZpZy5hdXRvRmV0Y2g7XG4gICAgdGhpcy51cGRhdGVSZW1vdGVzKCk7XG4gICAgdGhpcy5pc0ZldGNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5mZXRjaERlYm91bmNlZCA9IF8uZGVib3VuY2UoKCkgPT4gdGhpcy5mZXRjaCh7IHRhZ3M6IHRydWUgfSksIDUwMCk7XG4gIH1cblxuICB1cGRhdGVOb2RlKHBhcmVudEVsZW1lbnQpIHtcbiAgICBrby5yZW5kZXJUZW1wbGF0ZSgncmVtb3RlcycsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIGNsaWNrRmV0Y2goKSB7IHRoaXMuZmV0Y2goeyBub2RlczogdHJ1ZSwgdGFnczogdHJ1ZSB9KTsgfVxuXG4gIG9uUHJvZ3JhbUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmV2ZW50ID09PSAnd29ya2luZy10cmVlLWNoYW5nZWQnIHx8IGV2ZW50LmV2ZW50ID09PSAncmVxdWVzdC1hcHAtY29udGVudC1yZWZyZXNoJyB8fFxuICAgICAgZXZlbnQuZXZlbnQgPT09ICdyZXF1ZXN0LWZldGNoLXRhZ3MnIHx8IGV2ZW50LmV2ZW50ID09PSAnZ2l0LWRpcmVjdG9yeS1jaGFuZ2VkJykge1xuICAgICAgdGhpcy5mZXRjaERlYm91bmNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZldGNoKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5pc0ZldGNoaW5nIHx8ICF0aGlzLmN1cnJlbnRSZW1vdGUoKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5pc0ZldGNoaW5nID0gdHJ1ZTtcbiAgICBjb25zdCB0YWdQcm9taXNlID0gb3B0aW9ucy50YWdzID8gdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL3JlbW90ZS90YWdzJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIHJlbW90ZTogdGhpcy5jdXJyZW50UmVtb3RlKCkgfSkgOiBudWxsO1xuICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9IG9wdGlvbnMubm9kZXMgPyB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL2ZldGNoJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIHJlbW90ZTogdGhpcy5jdXJyZW50UmVtb3RlKCkgfSkgOiBudWxsO1xuICAgIHJldHVybiBwcm9taXNlLnByb3BzKHt0YWc6IHRhZ1Byb21pc2UsIGZldGNoOiBmZXRjaFByb21pc2V9KVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy50YWdzKSB7XG4gICAgICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVtb3RlLXRhZ3MtdXBkYXRlJywgdGFnczogcmVzdWx0LnRhZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VydmVyLmlzSW50ZXJuZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNlcnZlci5pc0ludGVybmV0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgbGV0IGVycm9yTWVzc2FnZTtcbiAgICAgIGxldCBzdGRvdXQ7XG4gICAgICBsZXQgc3RkZXJyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gYFVuZ2l0IGhhcyBmYWlsZWQgdG8gZmV0Y2ggYSByZW1vdGUuICAke2Vyci5yZXMuYm9keS5lcnJvcn1gO1xuICAgICAgICBzdGRvdXQgPSBlcnIucmVzLmJvZHkuc3Rkb3V0O1xuICAgICAgICBzdGRlcnIgPSBlcnIucmVzLmJvZHkuc3RkZXJyO1xuICAgICAgfSBjYXRjaCAoZSkgeyBlcnJvck1lc3NhZ2UgPSAnJzsgfVxuXG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdDb3VsZCBub3QgcmVzb2x2ZSBob3N0JykpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLmlzSW50ZXJuZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNlcnZlci5pc0ludGVybmV0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ0NvdWxkIG5vdCByZXNvbHZlIGhvc3QuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgYXJlIGRpc2Nvbm5lY3RlZCBmcm9tIGludGVybmV0IGFuZCBubyBsb25nZXIgcHVzaCBvciBmZXRjaCBmcm9tIHJlbW90ZS4gSG93ZXZlciwgVW5naXQgd2lsbCBiZSBmdW5jdGlvbmFsIGZvciBsb2NhbCBnaXQgb3BlcmF0aW9ucy4nO1xuICAgICAgICAgIHN0ZG91dCA9ICcnO1xuICAgICAgICAgIHN0ZGVyciA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1lc3NhZ2UgaXMgYWxyZWFkeSBzZWVuLCBqdXN0IHJldHVyblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdnaXQtZXJyb3InLCBkYXRhOiB7XG4gICAgICAgIGlzV2FybmluZzogdHJ1ZSxcbiAgICAgICAgY29tbWFuZDogZXJyLnJlcy5ib2R5LmNvbW1hbmQsXG4gICAgICAgIGVycm9yOiBlcnIucmVzLmJvZHkuZXJyb3IsXG4gICAgICAgIHN0ZG91dCxcbiAgICAgICAgc3RkZXJyLFxuICAgICAgICByZXBvUGF0aDogZXJyLnJlcy5ib2R5LndvcmtpbmdEaXJlY3RvcnlcbiAgICAgIH0gfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7IHRoaXMuaXNGZXRjaGluZyA9IGZhbHNlOyB9KTtcbiAgfVxuXG4gIHVwZGF0ZVJlbW90ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyLmdldFByb21pc2UoJy9yZW1vdGVzJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCkgfSlcbiAgICAgIC50aGVuKHJlbW90ZXMgPT4ge1xuICAgICAgICByZW1vdGVzID0gcmVtb3Rlcy5tYXAocmVtb3RlID0+ICh7XG4gICAgICAgICAgbmFtZTogcmVtb3RlLFxuICAgICAgICAgIGNoYW5nZVJlbW90ZTogKCkgPT4geyB0aGlzLmN1cnJlbnRSZW1vdGUocmVtb3RlKTsgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMucmVtb3RlcyhyZW1vdGVzKTtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRSZW1vdGUoKSAmJiByZW1vdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoXy5maW5kKHJlbW90ZXMsIHsgJ25hbWUnOiAnb3JpZ2luJyB9KSkgey8vIGRlZmF1bHQgdG8gb3JpZ2luIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVtb3RlKCdvcmlnaW4nKTtcbiAgICAgICAgICB9IGVsc2Ugey8vIG90aGVyd2lzZSB0YWtlIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlbW90ZShyZW1vdGVzWzBdLm5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnNob3VsZEF1dG9GZXRjaCkge1xuICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvRmV0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKHsgbm9kZXM6IHRydWUsIHRhZ3M6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbm90LWEtcmVwb3NpdG9yeScpIHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlcnIpO1xuICAgICAgfSk7XG4gIH1cblxuICBzaG93QWRkUmVtb3RlRGlhbG9nKCkge1xuICAgIGNvbXBvbmVudHMuY3JlYXRlKCdhZGRyZW1vdGVkaWFsb2cnKVxuICAgICAgLnNob3coKVxuICAgICAgLmNsb3NlVGhlbigoZGlhZykgPT4ge1xuICAgICAgICBpZihkaWFnLmlzU3VibWl0dGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoYC9yZW1vdGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGRpYWcubmFtZSgpKX1gLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgdXJsOiBkaWFnLnVybCgpIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7IHRoaXMudXBkYXRlUmVtb3RlcygpOyB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHJlbW90ZVJlbW92ZShyZW1vdGUpIHtcbiAgICBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlPycsIGRldGFpbHM6IGBEZWxldGluZyAke3JlbW90ZS5uYW1lfSByZW1vdGUgY2Fubm90IGJlIHVuZG9uZSB3aXRoIHVuZ2l0LmB9KVxuICAgICAgLnNob3coKVxuICAgICAgLmNsb3NlVGhlbigoZGlhZykgPT4ge1xuICAgICAgICBpZiAoZGlhZy5yZXN1bHQoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlci5kZWxQcm9taXNlKGAvcmVtb3Rlcy8ke3JlbW90ZS5uYW1lfWAsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7IHRoaXMudXBkYXRlUmVtb3RlcygpOyB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxufVxuIl19
